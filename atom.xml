<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Gowi&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-08-18T07:46:50.920Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Gowi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OpenCV-Python小白进阶之位运算与掩膜</title>
    <link href="http://yoursite.com/2019/08/18/OpenCV-Python%E5%B0%8F%E7%99%BD%E8%BF%9B%E9%98%B6%E4%B9%8B%E4%BD%8D%E8%BF%90%E7%AE%97%E4%B8%8E%E6%8E%A9%E8%86%9C/"/>
    <id>http://yoursite.com/2019/08/18/OpenCV-Python小白进阶之位运算与掩膜/</id>
    <published>2019-08-18T02:38:56.000Z</published>
    <updated>2019-08-18T07:46:50.920Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OpenCV-Python小白进阶之位运算与掩膜"><a href="#OpenCV-Python小白进阶之位运算与掩膜" class="headerlink" title="OpenCV-Python小白进阶之位运算与掩膜"></a>OpenCV-Python小白进阶之位运算与掩膜</h1><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p> 由于图片是有一个个0和1组成的，所以OpenCV中对图像也支持为运算（与或非等）</p> <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dst = cv2.bitwise_and(src1，src2[，dst[，mask]])</span><br><span class="line">dst= cv2.bitwise_not(src[, dst[, mask]])</span><br><span class="line">dst= cv2.bitwise_or(src1, src2[, dst[, mask]])</span><br><span class="line">dst= cv2.bitwise_xor(src1, src2[, dst[, mask]])</span><br></pre></td></tr></table></figure> <font color="#FF00," size="3"> bitwise_and是对二进制数据进行“与”操作，即对图像（灰度图像或彩色图像均可）每个像素值进行二进制“与”操作，1&1=1，1&0=0，0&1=0，0&0=0<p>bitwise_or是对二进制数据进行“或”操作，即对图像（灰度图像或彩色图像均可）每个像素值进行二进制“或”操作，1|1=1，1|0=0，0|1=0，0|0=0</p><p>bitwise_xor是对二进制数据进行“异或”操作，即对图像（灰度图像或彩色图像均可）每个像素值进行二进制“异或”操作，1^1=0,1^0=1,0^1=1,0^0=0</p><p>bitwise_not是对二进制数据进行“非”操作，即对图像（灰度图像或彩色图像均可）每个像素值进行二进制“非”操作，<del>1=0，</del>0=1<br></p></font><p></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'cv.jpg'</span>)</span><br><span class="line"><span class="comment"># cv2.imshow('image',img)</span></span><br><span class="line"></span><br><span class="line">rectangle = np.zeros(img.shape[<span class="number">0</span>:<span class="number">2</span>], dtype=<span class="string">'uint8'</span>)</span><br><span class="line">cv2.rectangle(rectangle, (<span class="number">25</span>, <span class="number">25</span>), (<span class="number">275</span>, <span class="number">275</span>), <span class="number">255</span>, <span class="number">-1</span>)</span><br><span class="line">cv2.imshow(<span class="string">'rectangle'</span>, rectangle)</span><br><span class="line"></span><br><span class="line">circle = np.zeros(img.shape[<span class="number">0</span>:<span class="number">2</span>], dtype=<span class="string">'uint8'</span>)</span><br><span class="line">cv2.circle(circle, (<span class="number">150</span>, <span class="number">150</span>), <span class="number">150</span>, <span class="number">255</span>, <span class="number">-1</span>)</span><br><span class="line">cv2.imshow(<span class="string">'circle'</span>, circle)</span><br><span class="line"></span><br><span class="line">bit_and = cv2.bitwise_and(rectangle, circle)</span><br><span class="line">cv2.imshow(<span class="string">'and'</span>, bit_and)</span><br><span class="line"></span><br><span class="line">bit_or = cv2.bitwise_or(rectangle, circle)</span><br><span class="line">cv2.imshow(<span class="string">'or'</span>, bit_or)</span><br><span class="line"></span><br><span class="line">bit_xor = cv2.bitwise_xor(rectangle, circle)</span><br><span class="line">cv2.imshow(<span class="string">'xor'</span>, bit_xor)</span><br><span class="line"></span><br><span class="line">bit_not1 = cv2.bitwise_not(rectangle)</span><br><span class="line">cv2.imshow(<span class="string">'not1'</span>, bit_not1)</span><br><span class="line"></span><br><span class="line">bit_not2 = cv2.bitwise_not(circle)</span><br><span class="line">cv2.imshow(<span class="string">'not2'</span>, bit_not2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">True</span>):</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">0</span>)==<span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p><img src="/2019/08/18/OpenCV-Python小白进阶之位运算与掩膜/t1.png" alt="aratar"><br><img src="/2019/08/18/OpenCV-Python小白进阶之位运算与掩膜/t2.png" alt="aratar"><br><img src="/2019/08/18/OpenCV-Python小白进阶之位运算与掩膜/t3.png" alt="aratar"><br><img src="/2019/08/18/OpenCV-Python小白进阶之位运算与掩膜/t4.png" alt="aratar"><br><img src="/2019/08/18/OpenCV-Python小白进阶之位运算与掩膜/t5.png" alt="aratar"><br><img src="/2019/08/18/OpenCV-Python小白进阶之位运算与掩膜/t6.png" alt="aratar"><br><img src="/2019/08/18/OpenCV-Python小白进阶之位运算与掩膜/t7.png" alt="aratar"></p><h2 id="掩膜"><a href="#掩膜" class="headerlink" title="掩膜"></a>掩膜</h2><p>用选定的图像、图形或物体，对处理的图像（全部或局部）进行遮挡，来控制图像处理的区域或处理过程。用于覆盖的特定图像或物体称为掩模或模板。光学图像处理中,掩模可以是胶片、滤光片等。数字图像处理中,掩模为二维矩阵数组,有时也用多值图像。</p><p>数字图像处理中，图像掩模主要用于：</p><p>①提取感兴趣区,用预先制作的感兴趣区掩模与待处理图像相乘,得到感兴趣区图像,感兴趣区内图像值保持不变,而区外图像值都为0。</p><p>②屏蔽作用,用掩模对图像上某些区域作屏蔽,使其不参加处理或不参加处理参数的计算,或仅对屏蔽区作处理或统计。</p><p>③结构特征提取,用相似性变量或图像匹配方法检测和提取图像中与掩模相似的结构特征。</p><p>④特殊形状图像的制作。<br>掩膜是一种图像滤镜的模板，实用掩膜经常处理的是遥感图像。当提取道路或者河流，或者房屋时，通过一个n*n的矩阵来对图像进行像素过滤，然后将我们需要的地物或者标志突出显示出来。这个矩阵就是一种掩膜。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"></span><br><span class="line">cv.namedWindow(<span class="string">'image'</span>, <span class="number">0</span>)</span><br><span class="line">cv.resizeWindow(<span class="string">'image'</span>, <span class="number">720</span>, <span class="number">480</span>)</span><br><span class="line"><span class="comment"># 加载两张图片</span></span><br><span class="line">img1 = cv.imread(<span class="string">'a.jpg'</span>)</span><br><span class="line">img2 = cv.imread(<span class="string">'a.jpeg'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我想在左上角放置标识，所以我创建了一个ROI</span></span><br><span class="line">rows,cols,channels = img2.shape</span><br><span class="line">roi = img1[<span class="number">0</span>:rows, <span class="number">0</span>:cols ]</span><br><span class="line"><span class="comment"># 现在创建一个徽标掩码并创建其反转掩码</span></span><br><span class="line">img2gray = cv.cvtColor(img2,cv.COLOR_BGR2GRAY)</span><br><span class="line">ret, mask = cv.threshold(img2gray, <span class="number">10</span>, <span class="number">255</span>, cv.THRESH_BINARY)</span><br><span class="line">mask_inv = cv.bitwise_not(mask)</span><br><span class="line"><span class="comment"># 现在使ROI中的徽标区域变黑</span></span><br><span class="line">img1_bg = cv.bitwise_and(roi,roi,mask = mask_inv)</span><br><span class="line"><span class="comment"># 仅从徽标图像中获取徽标区域。</span></span><br><span class="line">img2_fg = cv.bitwise_and(img2,img2,mask = mask)</span><br><span class="line"><span class="comment"># 在ROI中放置徽标并修改主图像</span></span><br><span class="line">dst = cv.add(img1_bg,img2_fg)</span><br><span class="line">img1[<span class="number">0</span>:rows, <span class="number">0</span>:cols ] = dst</span><br><span class="line">cv.imshow(<span class="string">'image'</span>,img1)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure><p><img src="/2019/08/18/OpenCV-Python小白进阶之位运算与掩膜/cv1.jpg" alt="aratar"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;OpenCV-Python小白进阶之位运算与掩膜&quot;&gt;&lt;a href=&quot;#OpenCV-Python小白进阶之位运算与掩膜&quot; class=&quot;headerlink&quot; title=&quot;OpenCV-Python小白进阶之位运算与掩膜&quot;&gt;&lt;/a&gt;OpenCV-Python小
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>OpenCv-Python小白进阶之进度条createTrackbar</title>
    <link href="http://yoursite.com/2019/08/17/OpenCv-Python%E5%B0%8F%E7%99%BD%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%BF%9B%E5%BA%A6%E6%9D%A1createTrackbar/"/>
    <id>http://yoursite.com/2019/08/17/OpenCv-Python小白进阶之进度条createTrackbar/</id>
    <published>2019-08-17T09:30:18.000Z</published>
    <updated>2019-08-17T15:02:32.468Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OpenCv-Python小白进阶之进度条createTrackbar"><a href="#OpenCv-Python小白进阶之进度条createTrackbar" class="headerlink" title="OpenCv-Python小白进阶之进度条createTrackbar"></a>OpenCv-Python小白进阶之进度条createTrackbar</h1><h2 id="createTrackbar"><a href="#createTrackbar" class="headerlink" title="createTrackbar"></a>createTrackbar</h2><p><font color="##FF0000">int createTrackbar(const string&amp; trackbarname, const string&amp;winname, int* value,  int count ，TrackbarCallback onChange = 0,  void* userdata = 0)</font>       </p><p>参数1：轨迹条名字</p><p>参数2：窗口名字</p><p>参数3：滑块初始位置</p><p>参数4：表示滑块达到最大位置的值</p><p>参数5：默认值为0，指向回调函数</p><p>参数6：默认值为0，用户传给回调函数的数据值</p><h2 id="getTrackbar"><a href="#getTrackbar" class="headerlink" title="getTrackbar"></a>getTrackbar</h2><p><font color="#FF0000">int getTrackbarPos(const string&amp; trackbarname, const string&amp; winname)</font></p><p>函数作用：</p><p>获取滑动条的位置的值</p><p>参数1:进度条名称</p><p>参数2:窗口名称</p><p>返回值：进度条位置</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'a.jpg'</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> img.size</span><br><span class="line"><span class="keyword">print</span> img.dtype</span><br><span class="line"></span><br><span class="line">cv2.namedWindow(<span class="string">'image'</span>, <span class="number">0</span>)</span><br><span class="line">cv2.resizeWindow(<span class="string">'image'</span>, <span class="number">720</span>, <span class="number">480</span>)</span><br><span class="line"></span><br><span class="line">cv2.createTrackbar(<span class="string">'num'</span>,<span class="string">'image'</span>,<span class="number">0</span>,<span class="number">255</span>,<span class="keyword">lambda</span> x: <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">    num = cv2.getTrackbarPos(<span class="string">'num'</span>,<span class="string">'image'</span>)</span><br><span class="line">    ret, thresh1 = cv2.threshold(img, num, <span class="number">255</span>, cv2.THRESH_BINARY)</span><br><span class="line">    cv2.imshow(<span class="string">'image'</span>, thresh1)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) == <span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p><img src="/2019/08/17/OpenCv-Python小白进阶之进度条createTrackbar/t0.png" alt="aratar"></p><p><img src="/2019/08/17/OpenCv-Python小白进阶之进度条createTrackbar/t1.png" alt="aratar"></p><p><img src="/2019/08/17/OpenCv-Python小白进阶之进度条createTrackbar/t2.png" alt="aratar"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;OpenCv-Python小白进阶之进度条createTrackbar&quot;&gt;&lt;a href=&quot;#OpenCv-Python小白进阶之进度条createTrackbar&quot; class=&quot;headerlink&quot; title=&quot;OpenCv-Python小白进阶之进度条c
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>OpenCV-Python小白进阶之图像固定阈值二值化处理threshold</title>
    <link href="http://yoursite.com/2019/08/17/OpenCV-Python%E5%B0%8F%E7%99%BD%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%9B%BE%E5%83%8F%E5%9B%BA%E5%AE%9A%E9%98%88%E5%80%BC%E4%BA%8C%E5%80%BC%E5%8C%96%E5%A4%84%E7%90%86threshold/"/>
    <id>http://yoursite.com/2019/08/17/OpenCV-Python小白进阶之图像固定阈值二值化处理threshold/</id>
    <published>2019-08-17T08:41:26.000Z</published>
    <updated>2019-08-17T15:15:46.067Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OpenCV-Python小白进阶之图像固定阈值二值化处理threshold"><a href="#OpenCV-Python小白进阶之图像固定阈值二值化处理threshold" class="headerlink" title="OpenCV-Python小白进阶之图像固定阈值二值化处理threshold"></a>OpenCV-Python小白进阶之图像固定阈值二值化处理threshold</h1><h2 id="二值化"><a href="#二值化" class="headerlink" title="二值化"></a>二值化</h2><p><font color="#FF00">定义：图像的二值化，就是将图像上的像素点的灰度值设置为0或255，也就是将整个图像呈现出明显的只有黑和白的视觉效果。灰度值0：黑，灰度值255：白</font></p><p>   一幅图像包括目标物体、背景还有噪声，要想从多值的数字图像中直接提取出目标物体，常用的方法就是设定一个阈值T，用T将图像的数据分成两部分：大于T的像素群和小于T的像素群。这是研究灰度变换的最特殊的方法，称为图像的二值化（Binarization）。</p><h2 id="threshold"><a href="#threshold" class="headerlink" title="threshold"></a>threshold</h2><p> cv2.threshold(img, threshold, maxval,type)</p><p>其中：</p><p>threshold是设定的阈值</p><p>maxval是当灰度值大于（或小于）阈值时将该灰度值赋成的值</p><p>type规定的是当前二值化的方式</p><p><img src="/2019/08/17/OpenCV-Python小白进阶之图像固定阈值二值化处理threshold/t0.png" alt="aratar"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">img1 = cv2.imread(<span class="string">'opencv.png'</span>, cv2.IMREAD_GRAYSCALE)</span><br><span class="line"><span class="comment"># cv2.THRESH_OTSU   作为图像自适应二值化的一个很优的算法Otsu大津算法的参数</span></span><br><span class="line">ret, binary = cv2.threshold(img1, <span class="number">175</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</span><br><span class="line"><span class="comment"># cv2.THRESH_BINARY    大于阈值的部分被置为255，小于部分被置为0</span></span><br><span class="line">ret, binaryinv = cv2.threshold(img1, <span class="number">175</span>, <span class="number">255</span>, cv2.THRESH_BINARY_INV)</span><br><span class="line"><span class="comment"># cv2.THRESH_BINARY_INV    大于阈值部分被置为0，小于部分被置为255</span></span><br><span class="line">ret, trunc = cv2.threshold(img1, <span class="number">175</span>, <span class="number">255</span>, cv2.THRESH_TRUNC)</span><br><span class="line"><span class="comment"># cv2.THRESH_TRUNC     大于阈值部分被置为threshold，小于部分保持原样</span></span><br><span class="line">ret, tozero = cv2.threshold(img1, <span class="number">175</span>, <span class="number">255</span>, cv2.THRESH_TOZERO)</span><br><span class="line"><span class="comment"># cv2.THRESH_TOZERO   小于阈值部分被置为0，大于部分保持不变</span></span><br><span class="line">ret, tozeroinv = cv2.threshold(img1, <span class="number">175</span>, <span class="number">255</span>, cv2.THRESH_TOZERO_INV)</span><br><span class="line"><span class="comment"># cv2.THRESH_TOZERO_INV    大于阈值部分被置为0，小于部分保持不变</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    cv2.imshow(<span class="string">'img1'</span>, img1)</span><br><span class="line">    cv2.imshow(<span class="string">'binary'</span>, binary)</span><br><span class="line">    cv2.imshow(<span class="string">'binaryinv'</span>, binaryinv)</span><br><span class="line">    cv2.imshow(<span class="string">'trunc'</span>, trunc)</span><br><span class="line">    cv2.imshow(<span class="string">'tozero'</span>, tozero)</span><br><span class="line">    cv2.imshow(<span class="string">'tozeroinv'</span>, tozeroinv)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) == <span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p><img src="/2019/08/17/OpenCV-Python小白进阶之图像固定阈值二值化处理threshold/t1.png" alt="aratar"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;OpenCV-Python小白进阶之图像固定阈值二值化处理threshold&quot;&gt;&lt;a href=&quot;#OpenCV-Python小白进阶之图像固定阈值二值化处理threshold&quot; class=&quot;headerlink&quot; title=&quot;OpenCV-Python小白进
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>OpenCV-Python小白进阶之获取像素点</title>
    <link href="http://yoursite.com/2019/08/16/OpenCV-Python%E5%B0%8F%E7%99%BD%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%8E%B7%E5%8F%96%E5%83%8F%E7%B4%A0%E7%82%B9/"/>
    <id>http://yoursite.com/2019/08/16/OpenCV-Python小白进阶之获取像素点/</id>
    <published>2019-08-16T12:34:29.000Z</published>
    <updated>2019-08-16T12:46:08.167Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OpenCV-Python小白进阶之获取像素点"><a href="#OpenCV-Python小白进阶之获取像素点" class="headerlink" title="OpenCV-Python小白进阶之获取像素点"></a>OpenCV-Python小白进阶之获取像素点</h1><h2 id="灰度图"><a href="#灰度图" class="headerlink" title="灰度图"></a>灰度图</h2><p>因为灰度图不具有RGB值，所以的img是一个二维数组，第一维表示行，第二维表示列</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3> <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> img.shape</span><br><span class="line"><span class="keyword">print</span> img[<span class="number">1</span>][<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h2 id="彩色图"><a href="#彩色图" class="headerlink" title="彩色图"></a>彩色图</h2><p>因为彩色图具有RGB值，所以的img是一个三维数组，第一维表示行，第二维表示列，第三维表示RGB通道,0表示b，1表示g，2表示r</p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> img.shape</span><br><span class="line"><span class="keyword">print</span> img[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;OpenCV-Python小白进阶之获取像素点&quot;&gt;&lt;a href=&quot;#OpenCV-Python小白进阶之获取像素点&quot; class=&quot;headerlink&quot; title=&quot;OpenCV-Python小白进阶之获取像素点&quot;&gt;&lt;/a&gt;OpenCV-Python小白进阶
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>OpenCV-Python小白进阶之灰度转化、分离RGB与直方图显示</title>
    <link href="http://yoursite.com/2019/08/15/OpenCV-Python%E5%B0%8F%E7%99%BD%E8%BF%9B%E9%98%B6%E4%B9%8B%E7%81%B0%E5%BA%A6%E8%BD%AC%E5%8C%96%E3%80%81%E5%88%86%E7%A6%BBRGB%E4%B8%8E%E7%9B%B4%E6%96%B9%E5%9B%BE%E6%98%BE%E7%A4%BA/"/>
    <id>http://yoursite.com/2019/08/15/OpenCV-Python小白进阶之灰度转化、分离RGB与直方图显示/</id>
    <published>2019-08-15T08:29:28.000Z</published>
    <updated>2019-08-15T09:44:49.569Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OpenCV-Python小白进阶之灰度转化、分离RGB与直方图显示"><a href="#OpenCV-Python小白进阶之灰度转化、分离RGB与直方图显示" class="headerlink" title="OpenCV-Python小白进阶之灰度转化、分离RGB与直方图显示"></a>OpenCV-Python小白进阶之灰度转化、分离RGB与直方图显示</h1><p>@[toc]</p><h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><p>环境：OpenCV Pycharm python3.7<br>素材：<br><img src="/2019/08/15/OpenCV-Python小白进阶之灰度转化、分离RGB与直方图显示/p1.jpg" alt="aratar"></p><h2 id="转化为灰度图"><a href="#转化为灰度图" class="headerlink" title="转化为灰度图"></a>转化为灰度图</h2><h3 id="函数："><a href="#函数：" class="headerlink" title="函数："></a>函数：</h3><font color="#ff0000">cv2.imread(path)</font><p>载入图片</p><font color="#ff0000">cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)</font><p>把img图片从RGB格式切换为GRAY</p><font color="#ff0000">cv2.namedWindow(name, aotusize)</font><p>给窗口命名，大小不可自由调整</p><font color="#ff0000">cv2.resizeWindow(name, length, width)</font><p>给窗口设置长与宽</p><font color="#f0000">cv2.imshow(name, img)</font><p>显示img图片</p><font color="#ff000">cv2.imwrite(path, img)</font><p>创建path路径并写入img图片</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'p1.jpg'</span>)</span><br><span class="line">img0 = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)</span><br><span class="line">cv2.imwrite(<span class="string">'p2.jpg'</span>, img0)</span><br><span class="line"></span><br><span class="line">cv2.namedWindow(<span class="string">'figure1'</span>, <span class="number">0</span>)</span><br><span class="line">cv2.resizeWindow(<span class="string">'figure1'</span>, <span class="number">960</span>, <span class="number">480</span>)</span><br><span class="line">cv2.imshow(<span class="string">'figure1'</span>, img0)</span><br></pre></td></tr></table></figure><p>输出</p><p><img src="/2019/08/15/OpenCV-Python小白进阶之灰度转化、分离RGB与直方图显示/p2.jpg" alt="aratar"></p><h2 id="分离RGB"><a href="#分离RGB" class="headerlink" title="分离RGB"></a>分离RGB</h2><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><font color="#ff000">cv2.split(img)</font><p>分离img图片的RGB，<font color="#ffd700," size="4">注意！！！电脑是以BGR的顺序分离的<br></font></p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'p1.jpg'</span>)</span><br><span class="line">img0 = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)</span><br><span class="line">cv2.imwrite(<span class="string">'p2.jpg'</span>, img0)</span><br><span class="line"></span><br><span class="line">cv2.namedWindow(<span class="string">'figure1'</span>, <span class="number">0</span>)</span><br><span class="line">cv2.resizeWindow(<span class="string">'figure1'</span>, <span class="number">960</span>, <span class="number">480</span>)</span><br><span class="line">cv2.imshow(<span class="string">'figure1'</span>, img0)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> [<span class="string">'Blue'</span>, <span class="string">"Green"</span>, <span class="string">'Red'</span>]:</span><br><span class="line">    cv2.namedWindow(col, <span class="number">0</span>)</span><br><span class="line">    cv2.resizeWindow(col, <span class="number">960</span>, <span class="number">480</span>)</span><br><span class="line">b, g, r = cv2.split(img)</span><br><span class="line"></span><br><span class="line">cv2.imwrite(<span class="string">'Blue.jpg'</span>, b)</span><br><span class="line">cv2.imwrite(<span class="string">'Red.jpg'</span>, r)</span><br><span class="line">cv2.imwrite(<span class="string">'Green.jpg'</span>, g)</span><br><span class="line"></span><br><span class="line">cv2.imwrite(<span class="string">'Blue.jpg'</span>, b)</span><br><span class="line">cv2.imwrite(<span class="string">'Red.jpg'</span>, r)</span><br><span class="line">cv2.imwrite(<span class="string">'Green.jpg'</span>, g)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p>输出<br>red<br><img src="/2019/08/15/OpenCV-Python小白进阶之灰度转化、分离RGB与直方图显示/Red.jpg" alt="aratar"><br>blue<br><img src="/2019/08/15/OpenCV-Python小白进阶之灰度转化、分离RGB与直方图显示/Blue.jpg" alt="aratar"><br>Green<br><img src="/2019/08/15/OpenCV-Python小白进阶之灰度转化、分离RGB与直方图显示/Green.jpg" alt="aratar"></p><h2 id="直方图显示"><a href="#直方图显示" class="headerlink" title="直方图显示"></a>直方图显示</h2><h3 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h3><font color="#ff0000">cv2.calcHist(images, channels, mask, histSize, ranges[, hist[, accumulate ]]) </font>第一个参数必须用方括号括起来。第二个参数是用于计算直方图的通道，这里使用灰度图计算直方图，所以就直接使用第一个通道；第三个参数是Mask，这里没有使用，所以用None。第四个参数是histSize，表示这个直方图分成多少份（即多少个直方柱）。第二个例子将绘出直方图，到时候会清楚一点。第五个参数是表示直方图中各个像素的值，[0.0, 256.0]表示直方图能表示像素值从0.0到256的像素。<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'p1.jpg'</span>)</span><br><span class="line">img0 = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)</span><br><span class="line">cv2.imwrite(<span class="string">'p2.jpg'</span>, img0)</span><br><span class="line"></span><br><span class="line">cv2.namedWindow(<span class="string">'figure1'</span>, <span class="number">0</span>)</span><br><span class="line">cv2.resizeWindow(<span class="string">'figure1'</span>, <span class="number">960</span>, <span class="number">480</span>)</span><br><span class="line">cv2.imshow(<span class="string">'figure1'</span>, img0)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> [<span class="string">'Blue'</span>, <span class="string">"Green"</span>, <span class="string">'Red'</span>]:</span><br><span class="line">    cv2.namedWindow(col, <span class="number">0</span>)</span><br><span class="line">    cv2.resizeWindow(col, <span class="number">960</span>, <span class="number">480</span>)</span><br><span class="line">b, g, r = cv2.split(img)</span><br><span class="line"></span><br><span class="line">cv2.imwrite(<span class="string">'Blue.jpg'</span>, b)</span><br><span class="line">cv2.imwrite(<span class="string">'Red.jpg'</span>, r)</span><br><span class="line">cv2.imwrite(<span class="string">'Green.jpg'</span>, g)</span><br><span class="line"></span><br><span class="line">r = cv2.imshow(<span class="string">"Red"</span>, r)</span><br><span class="line">g = cv2.imshow(<span class="string">"Green"</span>, g)</span><br><span class="line">b = cv2.imshow(<span class="string">"Blue"</span>, b)</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line">color = [<span class="string">'b'</span>, <span class="string">'g'</span>, <span class="string">'r'</span>]</span><br><span class="line"><span class="keyword">for</span> i, col <span class="keyword">in</span> enumerate(color):</span><br><span class="line">    histr = cv2.calcHist([img], [i], <span class="literal">None</span>, [<span class="number">256</span>], [<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line">    plt.plot(histr, color=col)</span><br><span class="line">    plt.xlim(<span class="number">0</span>, <span class="number">256</span>)</span><br><span class="line">    plt.ylim(<span class="number">0</span>, <span class="number">700000</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">histr = cv2.calcHist([img0], [<span class="number">0</span>], <span class="literal">None</span>, [<span class="number">256</span>], [<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line">plt.plot(histr, color=col)</span><br><span class="line">plt.xlim(<span class="number">0</span>, <span class="number">256</span>)</span><br><span class="line">plt.ylim(<span class="number">0</span>, <span class="number">700000</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>输出<br><img src="/2019/08/15/OpenCV-Python小白进阶之灰度转化、分离RGB与直方图显示/p3.png" alt="aratar"><br><img src="/2019/08/15/OpenCV-Python小白进阶之灰度转化、分离RGB与直方图显示/p4.png" alt="aratar"><br><img src="/2019/08/15/OpenCV-Python小白进阶之灰度转化、分离RGB与直方图显示/p5.png" alt="aratar"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;OpenCV-Python小白进阶之灰度转化、分离RGB与直方图显示&quot;&gt;&lt;a href=&quot;#OpenCV-Python小白进阶之灰度转化、分离RGB与直方图显示&quot; class=&quot;headerlink&quot; title=&quot;OpenCV-Python小白进阶之灰度转化、分
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>浅谈减而治之与分而治之</title>
    <link href="http://yoursite.com/2019/08/12/%E6%B5%85%E8%B0%88%E5%87%8F%E8%80%8C%E6%B2%BB%E4%B9%8B%E4%B8%8E%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B/"/>
    <id>http://yoursite.com/2019/08/12/浅谈减而治之与分而治之/</id>
    <published>2019-08-12T11:05:28.000Z</published>
    <updated>2019-08-12T11:09:07.082Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浅谈减而治之与分而治之"><a href="#浅谈减而治之与分而治之" class="headerlink" title="浅谈减而治之与分而治之"></a>浅谈减而治之与分而治之</h1><p>@[toc]</p><h2 id="减而治之"><a href="#减而治之" class="headerlink" title="减而治之"></a>减而治之</h2><p>线性递归（linear recursion）即减而治之（decrease-and-conquer）的思想：递归每深入一层，待求解问题的规模都缩减一个常数，直至最终蜕化为平凡的小（简单）问题。将一个规模为n的大问题退化为一个规模为n-1的小问题，直至退化为规模为1的平凡情况，这种情况称之为递归基（base case of recursion），当达到递归基时,算法将执行非递归计算。这一方法体现了算法的有穷性。<br>一般这种问题可以分为两个独立的子问题，其一用于单独的一个元素（如：递归出口），其二应用于剩余部分结构与原问题相同。子问题经合并后为原问题的解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fib</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">1</span>||n==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//递归出口</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Fib(n<span class="number">-1</span>)+Fib(n<span class="number">-2</span>);<span class="comment">//把问题分解成Fib(n-1)+Fib(n-2)来递归求解</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;Fib(n)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/08/12/浅谈减而治之与分而治之/20190727195323356.jpg" alt="aratar"></p><h2 id="分而治之"><a href="#分而治之" class="headerlink" title="分而治之"></a>分而治之</h2><p>二分递归（binary recursion）即分而治之（divide-and-conquer）的思想：将其分解为若干规模更小的子问题， 再通过递归机制分别求解。 这种分解持续进行，直到子问题规模缩减至平凡情况。在这种情况下，每一递归实例会调用多个递归来完成，故称作多路递归（multi-way recursion），通常都是将原问题一分为二，故有二分递归。<br>以下代码是对数组求和的二分递归的实现，新算法的思路是：以居中的元素为界将数组一分为二；递归地对子数组分别求和；最后，子数组之和相加即为原数组的总和。</p><p>可以用二路归并来理解<br>下面以vector的二路归并为例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::mergeSort(Rank lo, Rank hi)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (hi-lo&lt;<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mi=(lo+hi)&gt;&gt;<span class="number">2</span>;</span><br><span class="line">    mergeSort(lo, mi);</span><br><span class="line">    mergeSort(mi, hi);</span><br><span class="line">    merge(lo, mi, hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::merge(Rank lo, Rank mi, Rank hi)</span><br><span class="line">&#123;</span><br><span class="line">    T* A=_elem+lo;</span><br><span class="line">    <span class="keyword">int</span> lb=mi-lo;</span><br><span class="line">    T* B=<span class="keyword">new</span> T[lb];</span><br><span class="line">    <span class="keyword">for</span> (Rank i=<span class="number">0</span>; i&lt;lb; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        B[i]=A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> lc=hi-mi;</span><br><span class="line">    T* C=_elem+mi;</span><br><span class="line">    <span class="keyword">for</span> (Rank i=<span class="number">0</span>,j=<span class="number">0</span>,k=<span class="number">0</span>; j&lt;lb;i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((lc&lt;=k)||(B[j]&lt;=C[k]))</span><br><span class="line">        &#123;</span><br><span class="line">            A[i]=B[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((k&lt;lc)&amp;&amp;(C[k]&lt;B[j]))</span><br><span class="line">        &#123;</span><br><span class="line">            A[i]=C[k++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> [] B;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致内容如图所示：<br><img src="https://img-blog.csdnimg.cn/20190727195323356.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzA5Mjg2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>二路归并的意义在于把一个无序的向量分解成单个有序的元素，然后两两归并排序成为一个有序的向量，所以可以递归。二路归并体现了分而治之的思想。把一个向量一分为二，慢慢的变成单个的元素将问题缩减成很简单的情况。然后排序归并。</p><p>参考链接：<a href="https://juejin.im/post/5b9f8ffae51d450e83776059" target="_blank" rel="noopener">https://juejin.im/post/5b9f8ffae51d450e83776059</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;浅谈减而治之与分而治之&quot;&gt;&lt;a href=&quot;#浅谈减而治之与分而治之&quot; class=&quot;headerlink&quot; title=&quot;浅谈减而治之与分而治之&quot;&gt;&lt;/a&gt;浅谈减而治之与分而治之&lt;/h1&gt;&lt;p&gt;@[toc]&lt;/p&gt;
&lt;h2 id=&quot;减而治之&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C++多重继承的构造与析构的顺序</title>
    <link href="http://yoursite.com/2019/08/12/C-%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E7%9A%84%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84%E7%9A%84%E9%A1%BA%E5%BA%8F/"/>
    <id>http://yoursite.com/2019/08/12/C-多重继承的构造与析构的顺序/</id>
    <published>2019-08-12T02:32:50.000Z</published>
    <updated>2019-08-12T02:33:21.555Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-多重继承的构造与析构的次序"><a href="#C-多重继承的构造与析构的次序" class="headerlink" title="C++多重继承的构造与析构的次序"></a>C++多重继承的构造与析构的次序</h1><p><strong>在C++的多重继承中含有虚基类，成员对象时很容易把构造与析构的顺序弄不清楚</strong></p><p>下面看一段代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OBJ1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    OBJ1()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"OBJ1"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~OBJ1()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"~OBJ1"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OBJ2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    OBJ2()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"OBJ2"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~OBJ2()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"~OBJ2"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base1()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Base1"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Base1()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"~Base1"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base2()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Base2"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Base2()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"~Base2"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base3()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Base3"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Base3()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"~Base3"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base4</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base4()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Base4"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Base4()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"~Base4"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base1, <span class="keyword">virtual</span> <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base3, <span class="keyword">virtual</span> <span class="keyword">public</span> Base4</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived():Base4(),Base3(),Base2(),Base1(),obj2(),obj1()&#123;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    OBJ1 obj1;</span><br><span class="line">    OBJ2 obj2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived aa;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Base2</span><br><span class="line">Base4</span><br><span class="line">Base1</span><br><span class="line">Base3</span><br><span class="line">OBJ1</span><br><span class="line">OBJ2</span><br><span class="line">~OBJ2</span><br><span class="line">~OBJ1</span><br><span class="line">~Base3</span><br><span class="line">~Base1</span><br><span class="line">~Base4</span><br><span class="line">~Base2</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure><p>由此可知C++中多重继承的构造顺序是<br>1）虚函数优先构造，其顺序是按那个继承的顺序来的，而不是按初始化列表来的<br>2）然后构造普通的基类，其顺序也是按那个继承的顺序来的，不是按初始化列表来的<br>3）最后构造成员对象<br>4）构造派生类自己的函数体</p><p>由此可知C++中多重继承的析构顺序是<br>1）构造派生类自己的函数体<br>2）析造成员对象<br>3）然后析构普通的基类，其顺序也是按那个继承的顺序来的，也不是按初始化列表来的<br>4）最后是那个虚基类</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-多重继承的构造与析构的次序&quot;&gt;&lt;a href=&quot;#C-多重继承的构造与析构的次序&quot; class=&quot;headerlink&quot; title=&quot;C++多重继承的构造与析构的次序&quot;&gt;&lt;/a&gt;C++多重继承的构造与析构的次序&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;在C++的多重继
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>析构函数为虚函数</title>
    <link href="http://yoursite.com/2019/08/12/%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2019/08/12/析构函数为虚函数/</id>
    <published>2019-08-12T02:27:45.000Z</published>
    <updated>2019-08-12T02:28:35.532Z</updated>
    
    <content type="html"><![CDATA[<p>转载</p><blockquote><p><a href="https://blog.csdn.net/zhangqk2016/article/details/51849535" target="_blank" rel="noopener">https://blog.csdn.net/zhangqk2016/article/details/51849535</a></p></blockquote><p>多态是面向对象的一个基本属性，包括静态多态（编译阶段）和动态多态（运行阶段），静态多态主要是指函数参数不同产生的多态性，是在编译阶段可以识别的一种多态机制，而运行时多态则主要用于基类指针指向派生类对象时，可以通过基类指针直接调用派生类的对象函数，当然这种多态是通过虚函数实现的。</p><p>虚函数的目的就是通知系统在函数调用时能够自动识别对应的类对象类型，从而能够根据指针所指类型调用对应的类对象，实现函数调用时的多态性。对于析构函数而言，同样适用于上述规则。如果析构函数不是虚函数，那么在调用该函数时（对象被删除时）则只会调用当前对象对应的类的析构函数，这对于直接定义的对象是没有什么影响的，但是对于使用基类指向派生类的指针而言，因为基类指针实际上是基类类型，所以析构时自然只会调用基类的析构函数，这就可能产生内存泄漏（因为派生类的析构函数不被调用）。所以如果确定程序中有基类指针指向派生类的问题，则必须将基类的析构函数指定为虚函数，如此才能确保NEW出来的对象被正确的DELETE。</p><p>以下是几个示例程序，用于方便理解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClxBase</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ClxBase() &#123;&#125;;</span><br><span class="line">    ~ClxBase()</span><br><span class="line">     &#123;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">"Output from the destructor of class ClxBase!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Do something in class ClxBase!"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ClxDerived</span> :</span> <span class="keyword">public</span> ClxBase&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ClxDerived() &#123;&#125;;</span><br><span class="line">    ~ClxDerived() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Output from the destructor of class ClxDerived!"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Do something in class ClxDerived!"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>示例程序一：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">    ClxBase base;</span><br><span class="line">    </span><br><span class="line">    ClxDerived derived;</span><br><span class="line">    base.DoSomething();</span><br><span class="line">    </span><br><span class="line">    derived.DoSomething();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><pre><code>Do something in class ClxBase!Do something in class ClxDerived!Output from the destructor of class ClxDerived!Output from the destructor of class ClxBase!Output from the destructor of class ClxBase!</code></pre><p>分析：</p><p>从以上实例程序可以发现，正常构造的对象，派生类的析构函数会主动调用基类的析构函数，所以不会存在内存泄漏问题。</p><p>示例程序二：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">    ClxDerived *p = <span class="keyword">new</span> ClxDerived;</span><br><span class="line">    p-&gt;DoSomething();</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><pre><code>Do something in class ClxDerived!Output from the destructor of class ClxDerived!Output from the destructor of class ClxBase!</code></pre><p>分析：<br>从以上结果可以发现，派生类的指针在析构时，同样是运行指针所对应类型的派生类的析构函数，而此析构函数自然会调用基类的析构函数，所以也不会产生内存泄漏。</p><p>实例程序三：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">   ClxBase *p = <span class="keyword">new</span> ClxDerived;</span><br><span class="line">   p-&gt;DoSomething();</span><br><span class="line">   <span class="keyword">delete</span> p;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><pre><code>Do something in class ClxBase!Output from the destructor of class ClxBase!</code></pre><p>分析：</p><p>从以上结果可以发现，基类指针在析构时，会调用基类的析构函数，纵然其指向派生类，但其依然会调用基类的析构，所以派生类中如有需要释放的内存空间，则必然得不到释放，从而产生内存泄漏。</p><p>示例程序四：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClxBase</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ClxBase() &#123;&#125;;</span><br><span class="line">    <span class="keyword">virtual</span> ~ClxBase() &#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"Output from the destructor of class ClxBase!"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Do something in class ClxBase!"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ClxDerived</span> :</span> <span class="keyword">public</span> ClxBase&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ClxDerived() &#123;&#125;;</span><br><span class="line">    ~ClxDerived() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Output from the destructor of class ClxDerived!"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Do something in class ClxDerived!"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">    ClxBase *p = <span class="keyword">new</span> ClxDerived;</span><br><span class="line">    p-&gt;DoSomething();</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><pre><code>Do something in class ClxDerived!Output from the destructor of class ClxDerived!Output from the destructor of class ClxBase!</code></pre><p>分析：</p><p>以上结果可以发现，不管是普通成员函数还是析构函数，只有定义为虚函数，才能够在基类指针指向派生类对象时调用所指向对象的响应函数，从而在函数析构时能够正确的delete掉new出来的对象，不产生内存泄漏。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转载&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/zhangqk2016/article/details/51849535&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.c
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于虚函数与纯虚函数的几点小记</title>
    <link href="http://yoursite.com/2019/08/12/%E5%85%B3%E4%BA%8E%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%87%A0%E7%82%B9%E5%B0%8F%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/08/12/关于虚函数与纯虚函数的几点小记/</id>
    <published>2019-08-12T02:21:06.000Z</published>
    <updated>2019-08-12T02:22:03.875Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于虚函数与纯虚函数的几点"><a href="#关于虚函数与纯虚函数的几点" class="headerlink" title="关于虚函数与纯虚函数的几点"></a><strong>关于虚函数与纯虚函数的几点</strong></h1><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a><strong>虚函数</strong></h2><p>虚函数的关键字是virtual<br>虚函数是提供一种“推迟联编”或者“动态联编”的功能，来实现多态性，形成虚指针。虚函数的调用并不是在编译时刻被确定的，而是在运行时刻被确定的。</p><p>一个代码示列：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> Base1::display()<span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Base1::display()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span>:</span><span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> Base2::display()<span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Base2::display()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span><span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> Derived::display()<span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Derived::display()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(Base1 *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ptr-&gt;display();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base1 base1;</span><br><span class="line">    Base2 base2;</span><br><span class="line">    Derived derived;</span><br><span class="line">    fun(&amp;base1);</span><br><span class="line">    fun(&amp;base2);</span><br><span class="line">    fun(&amp;derived);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Base1::display()</span><br><span class="line">Base2::display()</span><br><span class="line">Derived::display()</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure><h2 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h2><p>纯虚函数是在基类中声明的虚函数，它在基类中没有定义，所以不能实例化不能产生对象。在基类中实现纯虚函数的方法是在函数原型后加“=0”<br>　virtual void funtion1()=0<br>其中虚函数的主要作用是：使基类中的纯虚函数仅仅只是继承函数的一个接口。<br>其中含有纯虚函数的类被称为抽象类，若抽象类在继承中纯虚函数还是没有被实现则还是抽象类<br>抽象类的作用：产生一个接口被派生类继承</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span>:</span><span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> Base2::display()<span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Base2::display()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span><span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> Derived::display()<span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Derivd::display()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(Base1 *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ptr-&gt;display();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base2 base2;</span><br><span class="line">    Derived derived;</span><br><span class="line">    fun(&amp;base2);</span><br><span class="line">    fun(&amp;derived);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Base2::display()</span><br><span class="line">Derivd::display()</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure><p>详情请看</p><blockquote><p><a href="https://blog.csdn.net/wang13342322203/article/details/80512330" target="_blank" rel="noopener">https://blog.csdn.net/wang13342322203/article/details/80512330</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关于虚函数与纯虚函数的几点&quot;&gt;&lt;a href=&quot;#关于虚函数与纯虚函数的几点&quot; class=&quot;headerlink&quot; title=&quot;关于虚函数与纯虚函数的几点&quot;&gt;&lt;/a&gt;&lt;strong&gt;关于虚函数与纯虚函数的几点&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;虚函数&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>浅谈Python多进程与多线程</title>
    <link href="http://yoursite.com/2019/08/12/%E6%B5%85%E8%B0%88Python%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/08/12/浅谈Python多进程与多线程/</id>
    <published>2019-08-12T00:25:35.000Z</published>
    <updated>2019-08-12T02:18:03.173Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浅谈Python多进程与多线程"><a href="#浅谈Python多进程与多线程" class="headerlink" title="浅谈Python多进程与多线程"></a>浅谈Python多进程与多线程</h1><p>@[toc]</p><h2 id="什么是进程，什么是线程"><a href="#什么是进程，什么是线程" class="headerlink" title="什么是进程，什么是线程"></a>什么是进程，什么是线程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程是程序的一次动态执行过程，它对应了从代码加载、执行到执行完毕的一个完整过程。<br>进程是资源分配的最小单位，进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵<br><font color="##FF0000," size="5">一个进程若不存在多线程则相当于线程</font></p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程是程序执行的最小单位，每个线程中可以实现资源的共享、通信等操作，<font color="##FF0000"> 但线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。</font></p><h3 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h3><table>    <tr>        <td> </td>        <td>进程</td>        <td>线程</td>    </tr>    <tr>        <td>相同点</td>        <td colspan="2">两者都是实现多个任务同时运行的方式</td>    </tr>    <tr>        <td>不同点</td>        <td colspan="2">进程拥有独立的资源，进程间相互独立，互不打扰，但线程之间更容易实现共享，同时多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。</td>    </tr></table><h2 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h2><p>在Unix与Linux中系统支持<font color="##FF0000," size="5">fork()</font>，但在我们常见的系统中不容许Windows可以使用，但Mac OS X与Linux可以使用,但Python是一门可以跨平台的编程语言，对任意系统都支持<font color="##FF0000," size="5">multiprocessing</font></p><p>其中：<br>os.getpid() 获取当前进程的PID号<br>os.getppid() 获取当前进程父进程的PID号</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="Mac-OS-X下使用fork（）创建子进程"><a href="#Mac-OS-X下使用fork（）创建子进程" class="headerlink" title="Mac OS X下使用fork（）创建子进程"></a>Mac OS X下使用fork（）创建子进程</h4><p>fork()语法：</p><p>功能：为当前进程创建一个子进程</p><p>参数：无</p><p>返回值：0 和 子进程PID（在父进程中）</p><p>　　　　&lt; 0 子进程创建失败</p><p>　　　　= 0 在子进程中的返回值</p><p>　　　　&gt; 0 在父进程中的返回值</p><p>fork()很特殊，它是一个调用一次，返回两次的函数<br><font color="##FF0000," size="5">子进程永远返回0，而父进程返回子进程的ID,所以一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用getppid()就可以拿到父进程的ID。</font></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment">#！usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># fork()属于系统内建函数，需从OS模块引入</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'process (%s) strat...'</span> %os.getpid()</span><br><span class="line"></span><br><span class="line">pid = os.fork()</span><br><span class="line"><span class="comment"># 调用一次，返回两次</span></span><br><span class="line"><span class="keyword">if</span> pid == <span class="number">0</span>:</span><br><span class="line"><span class="comment"># 判断是否为子进程</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"I'm child process (%s) and my parent is %s"</span> %(os.getpid(),os.getppid())</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"I (%s) just created a child process (%s)."</span> %(os.getpid(),pid)</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">process (58196) strat...</span><br><span class="line">I (58196) just created a child process (58198).</span><br><span class="line">I&apos;m child process (58198) and my parent is 58196</span><br></pre></td></tr></table></figure><h4 id="使用multiprocessing"><a href="#使用multiprocessing" class="headerlink" title="使用multiprocessing"></a>使用multiprocessing</h4><p>由于windows不可以使用fork（），但python为所有操作系统准备了multiprocess供它们创建子线程</p><p><font color="##FF00," size="5">创建子进程时，只需要传入一个执行函数和函数的参数，创建一个Process实例，用start()方法启动，这样创建进程比fork()还要简单。join()方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。</font></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment">#！usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="comment"># 从multiprocessing模块引入Process</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Run child process %s(%s)...'</span>%(name,os.getpid())</span><br><span class="line">    <span class="comment"># 打印当前进程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 若在本模块运行时</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Parent process %s.'</span>%os.getpid()</span><br><span class="line">    <span class="comment"># 打印父进程</span></span><br><span class="line">    p = Process(target=fun,args=(<span class="string">'test'</span>,))</span><br><span class="line">    <span class="comment"># 创建一个子进程</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Process will start.'</span></span><br><span class="line">    p.start()</span><br><span class="line">    <span class="comment"># 开始运行子进程</span></span><br><span class="line">    p.join()</span><br><span class="line">    <span class="comment"># 停止运行子进程</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Process end'</span></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Parent process 61028.</span><br><span class="line">Process will start.</span><br><span class="line">Run child process test(61029)...</span><br><span class="line">Process end</span><br></pre></td></tr></table></figure><h3 id="进程池"><a href="#进程池" class="headerlink" title="进程池"></a>进程池</h3><p>如果要启动大量的子进程，可以用进程池的方式批量创建子进程：</p><p>关键字为<font color="#FF45000," size="5">poll</font>，Pool的默认大小是CPU的核数；但它也可以设置参数如果为pool（5）则是申请有5个子进程的进程池<br><font color="##FF0000," size="6">注意：</font><br><font face="‘微软雅黑‘," color="#6495E," size="5">对Pool对象调用join()方法会等待所有子进程执行完毕，调用join()之前必须先调用close()，调用close()之后就不能继续添加新的Process了。</font></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment">#！usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="comment"># 从multiprocess模块引入Pool</span></span><br><span class="line"><span class="keyword">import</span> os,time,random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">long_time_task</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Run task%s(%s)'</span> % (name, os.getpid())</span><br><span class="line">    start = time.time()</span><br><span class="line">    time.sleep(random.random()*<span class="number">3</span>)</span><br><span class="line">    <span class="comment"># random.random（）产生一个0～1的随机数</span></span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Task %s runs %0.2f seconds'</span> % (name, (end-start))</span><br><span class="line">    <span class="comment"># 输出任务名与运行时间差</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Parent process %s.'</span> % os.getpid()</span><br><span class="line">    p = Pool()</span><br><span class="line">    <span class="comment"># 生成一个进程池</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        p.apply_async(long_time_task, args=(i,))</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Waiting for all subprocesses done...'</span></span><br><span class="line">    p.close()</span><br><span class="line">    p.join()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'All subprocess done'</span></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Parent process 66221.</span><br><span class="line">Waiting for all subprocesses done...</span><br><span class="line">Run task0(66223)</span><br><span class="line">Run task1(66224)</span><br><span class="line">Run task2(66225)</span><br><span class="line">Run task3(66226)</span><br><span class="line">Task 1 runs 0.69 seconds</span><br><span class="line">Run task4(66224)</span><br><span class="line">Task 4 runs 0.91 seconds</span><br><span class="line">Task 2 runs 1.97 seconds</span><br><span class="line">Task 3 runs 2.19 seconds</span><br><span class="line">Task 0 runs 3.00 seconds</span><br><span class="line">All subprocess done</span><br><span class="line">3.03261709213</span><br></pre></td></tr></table></figure><br><font color="#FFD70," size="5">因为我使用的是4核处理器，所以task 4要等待前面某个task完成后才执行</font><h3 id="多进程的通信"><a href="#多进程的通信" class="headerlink" title="多进程的通信"></a>多进程的通信</h3><h4 id="multiprocessing-Queue"><a href="#multiprocessing-Queue" class="headerlink" title="multiprocessing.Queue()"></a>multiprocessing.Queue()</h4><p>Queue是多进程安全的队列，可以使用Queue实现多进程之间的数据传递。put方法用以插入数据到队列中，put方法还有两个可选参数：blocked和timeout。如果blocked为True（默认值），并且timeout为正值，该方法会阻塞timeout指定的时间，直到该队列有剩余的空间。如果超时，会抛出Queue.Full异常。如果blocked为False，但该Queue已满，会立即抛出Queue.Full异常。</p><p>get方法可以从队列读取并且删除一个元素。同样，get方法有两个可选参数：blocked和timeout。如果blocked为True（默认值），并且timeout为正值，那么在等待时间内没有取到任何元素，会抛出Queue.Empty异常。如果blocked为False，有两种情况存在，如果Queue有一个值可用，则立即返回该值，否则，如果队列为空，则立即抛出Queue.Empty异常</p><br>以Queue为例，在父进程中创建两个子进程，一个往Queue里写数据，一个从Queue里读数据：<p>==multiprcessing.Queue.put() 为 入队操作==</p><p>==multiprcessing.Queue.get() 为 出队操作==</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment">#！usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">writer_proc</span><span class="params">(q)</span>:</span>      </span><br><span class="line">    <span class="keyword">try</span>:         </span><br><span class="line">        q.put(<span class="number">1</span>, block = <span class="literal">False</span>) </span><br><span class="line">    <span class="keyword">except</span>:         </span><br><span class="line">        <span class="keyword">pass</span>   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reader_proc</span><span class="params">(q)</span>:</span>      </span><br><span class="line">    <span class="keyword">try</span>:         </span><br><span class="line">        <span class="keyword">print</span> q.get(block = <span class="literal">False</span>) </span><br><span class="line">    <span class="keyword">except</span>:         </span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    q = multiprocessing.Queue()</span><br><span class="line">    writer = multiprocessing.Process(target=writer_proc, args=(q,))  </span><br><span class="line">    writer.start()   </span><br><span class="line"></span><br><span class="line">    reader = multiprocessing.Process(target=reader_proc, args=(q,))  </span><br><span class="line">    reader.start()  </span><br><span class="line"></span><br><span class="line">    reader.join()  </span><br><span class="line">    writer.join()</span><br></pre></td></tr></table></figure><h4 id="multiprocessing-Pipe"><a href="#multiprocessing-Pipe" class="headerlink" title="multiprocessing.Pipe()"></a>multiprocessing.Pipe()</h4><p>Pipe方法返回(conn1, conn2)代表一个管道的两个端。Pipe方法有duplex参数，如果duplex参数为True(默认值)，那么这个管道是全双工模式，也就是说conn1和conn2均可收发。duplex为False，conn1只负责接受消息，conn2只负责发送消息。</p><p>send和recv方法分别是发送和接受消息的方法。例如，在全双工模式下，可以调用conn1.send发送消息，conn1.recv接收消息。如果没有消息可接收，recv方法会一直阻塞。如果管道已经被关闭，那么recv方法会抛出EOFError。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment">#！usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">proc1</span><span class="params">(pipe)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"send: %s"</span> %(i)</span><br><span class="line">            pipe.send(i)</span><br><span class="line">            <span class="comment"># 向pipe中发送i值</span></span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">proc2</span><span class="params">(pipe)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"proc2 rev:"</span>, pipe.recv()</span><br><span class="line">        <span class="comment"># 接受i值</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    pipe = multiprocessing.Pipe()</span><br><span class="line">    <span class="comment"># 申请一个pipe</span></span><br><span class="line">    p1 = multiprocessing.Process(target=proc1, args=(pipe[<span class="number">0</span>],))</span><br><span class="line">    p2 = multiprocessing.Process(target=proc2, args=(pipe[<span class="number">1</span>],))</span><br><span class="line">    <span class="comment"># 生成两个子进程p1，p2</span></span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    <span class="comment"># 开始执行进程</span></span><br><span class="line">    p1.join()</span><br><span class="line">    p2.join()</span><br><span class="line">    <span class="comment"># 结束进程</span></span><br></pre></td></tr></table></figure><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>Python的标准库提供了两个模块：thread和threading，thread是低级模块，threading是高级模块，对thread进行了封装。绝大多数情况下，我们只需要使用threading这个高级模块。</p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p> <strong>单线程</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#-*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment">#！usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span>  range(<span class="number">3</span>):</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'我在看书'</span>,time.ctime()</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"我在听歌"</span>,time.ctime()</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">fun1()</span><br><span class="line">fun2()</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">我在看书 Fri Aug  9 22:34:41 2019</span><br><span class="line">我在看书 Fri Aug  9 22:34:42 2019</span><br><span class="line">我在看书 Fri Aug  9 22:34:43 2019</span><br><span class="line">我在听歌 Fri Aug  9 22:34:44 2019</span><br><span class="line">我在听歌 Fri Aug  9 22:34:45 2019</span><br><span class="line">我在听歌 Fri Aug  9 22:34:46 2019</span><br></pre></td></tr></table></figure><p><strong>多线程</strong><br>输出</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment">#！usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span>  threading</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span>  range(<span class="number">3</span>):</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'我在看书'</span>,time.ctime()</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"我在听歌"</span>,time.ctime()</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">p1 = threading.Thread(target=fun1)</span><br><span class="line"><span class="comment"># 创建一个线程p1</span></span><br><span class="line">p2 = threading.Thread(target=fun2)</span><br><span class="line"><span class="comment"># 创建一个线程p2</span></span><br><span class="line">p1.start()</span><br><span class="line">p2.start()</span><br><span class="line"><span class="comment"># 执行线程</span></span><br><span class="line">p1.join()</span><br><span class="line">p2.join()</span><br><span class="line"><span class="comment"># 结束线程</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">我在看书 Fri Aug  9 22:37:44 2019</span><br><span class="line">我在听歌 Fri Aug  9 22:37:44 2019</span><br><span class="line">我在看书 Fri Aug  9 22:37:45 2019</span><br><span class="line">我在听歌 Fri Aug  9 22:37:45 2019</span><br><span class="line">我在听歌 Fri Aug  9 22:37:46 2019</span><br><span class="line">我在看书 Fri Aug  9 22:37:46 2019</span><br></pre></td></tr></table></figure><h3 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h3><h4 id="由于线程通信造成的混乱"><a href="#由于线程通信造成的混乱" class="headerlink" title="由于线程通信造成的混乱"></a>由于线程通信造成的混乱</h4><p>多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment">#！usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">count = <span class="number">5</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> count</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span>  range(<span class="number">5</span>):</span><br><span class="line">        count += n</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        count -= n</span><br><span class="line">        <span class="keyword">print</span> count</span><br><span class="line"></span><br><span class="line">p1 = threading.Thread(target=fun,args=(<span class="number">5</span>,))</span><br><span class="line">p2 = threading.Thread(target=fun,args=(<span class="number">3</span>,))</span><br><span class="line"></span><br><span class="line">p1.start()</span><br><span class="line">p2.start()</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">5 </span><br><span class="line">8</span><br><span class="line">10</span><br><span class="line">8</span><br><span class="line">10</span><br><span class="line">8</span><br><span class="line">5</span><br><span class="line">8</span><br><span class="line">10</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>在Python中提供了关键字lock来防止由于线程通信造成的混乱。由于锁（lock）只有一个，无论多少线程，同一时刻最多只有一个线程持有该锁，所以，不会造成修改的冲突。所以获得lock的线程将会优先执行。所以lock会使各个线程依次执行。<font color="##ff0000," size="5">但使用lock时，threading.Lock()，要注意获取和释放锁， lock.acquire()、 lock.release()</font></p><p>示例代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment">#！usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> A, lock</span><br><span class="line">    lock.acquire()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        A += <span class="number">1</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Thread-1"</span>, A</span><br><span class="line">    lock.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> A, lock</span><br><span class="line">    lock.acquire()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        A += <span class="number">10</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Thread-2"</span>, A</span><br><span class="line">    lock.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    lock = threading.Lock()</span><br><span class="line">    A = <span class="number">0</span></span><br><span class="line">    t1 = threading.Thread(target=fun1)</span><br><span class="line">    t2 = threading.Thread(target=fun2)</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Thread-1 1</span><br><span class="line">Thread-1 2</span><br><span class="line">Thread-1 3</span><br><span class="line">Thread-1 4</span><br><span class="line">Thread-1 5</span><br><span class="line">Thread-1 6</span><br><span class="line">Thread-1 7</span><br><span class="line">Thread-1 8</span><br><span class="line">Thread-1 9</span><br><span class="line">Thread-1 10</span><br><span class="line">Thread-2 20</span><br><span class="line">Thread-2 30</span><br><span class="line">Thread-2 40</span><br><span class="line">Thread-2 50</span><br><span class="line">Thread-2 60</span><br><span class="line">Thread-2 70</span><br><span class="line">Thread-2 80</span><br><span class="line">Thread-2 90</span><br><span class="line">Thread-2 100</span><br><span class="line">Thread-2 110</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;浅谈Python多进程与多线程&quot;&gt;&lt;a href=&quot;#浅谈Python多进程与多线程&quot; class=&quot;headerlink&quot; title=&quot;浅谈Python多进程与多线程&quot;&gt;&lt;/a&gt;浅谈Python多进程与多线程&lt;/h1&gt;&lt;p&gt;@[toc]&lt;/p&gt;
&lt;h2 id=
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2019/08/12/hello-world/"/>
    <id>http://yoursite.com/2019/08/12/hello-world/</id>
    <published>2019-08-11T23:29:14.165Z</published>
    <updated>2019-08-11T23:29:14.165Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
