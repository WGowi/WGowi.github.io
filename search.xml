<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[OpenCV-Python小白进阶之图片的融合]]></title>
    <url>%2F2019%2F08%2F18%2FOpenCV-Python%E5%B0%8F%E7%99%BD%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%9B%BE%E7%89%87%E7%9A%84%E8%9E%8D%E5%90%88%2F</url>
    <content type="text"><![CDATA[OpenCV-Python小白进阶之图片的融合方法cv2.resize() https://wgowi.github.io/2019/08/18/OpenCV-Python%E5%B0%8F%E7%99%BD%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%9B%BE%E7%89%87%E7%9A%84%E4%BC%B8%E7%BC%A9%E5%8F%98%E6%8D%A2/#more cv2.addWeighted(img1, x, img2, y, 0) 把img1与img2按xy的比重融合 cv2.add(img1,img2) 将img1与img2按1:1融合 代码实现1234567891011121314151617181920import cv2img1 = cv2.imread('a.jpg')img2 = cv2.imread('cv.jpg')img3 = cv2.resize(img1, (400, 400))img4 = cv2.resize(img2, (400, 400))img5 = cv2.addWeighted(img3, 0.5, img4, 0.5, 0)img6 = cv2.add(img3,img4)img7 = cv2.addWeighted(img4, 1, img3, 1, 0)cv2.imshow('img5', img5)cv2.imshow('img6', img6)cv2.imshow('img7', img7)while True: if cv2.waitKey(1) == 27: breakcv2.destroyAllWindows() 由此可知cv2.addweighted()img1和img2的比重都为1时与cv2.add()相同]]></content>
  </entry>
  <entry>
    <title><![CDATA[OpenCV-Python小白进阶之图片的伸缩变换]]></title>
    <url>%2F2019%2F08%2F18%2FOpenCV-Python%E5%B0%8F%E7%99%BD%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%9B%BE%E7%89%87%E7%9A%84%E4%BC%B8%E7%BC%A9%E5%8F%98%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[OpenCV-Python小白进阶之图片的伸缩变换方法 cv2.resize(InputArray src, OutputArray dst, Size, fx, fy, interpolation) 参数： InputArray src：输入图片 OutputArray dst：输出图片 Size：输出图片尺寸 fx, fy： 沿x轴，y轴的缩放系数 interpolation： 插入方式 interpolation： 选项所用的插值方法： INTER_NEAREST：最近邻插值 INTER_LINEAR：双线性插值（默认设置） INTER_AREA：使用像素区域关系进行重采样。 INTER_CUBIC：4x4像素邻域的双三次插值 INTER_LANCZOS4：8x8像素邻域的Lanczos插值 代码实现 12345678910111213141516 import cv2img0 = cv2.imread('a.jpg')img1 = cv2.resize(img0, (600, 400), interpolation=cv2.INTER_NEAREST)img2 = cv2.resize(img0, (0,0),fx=0.1, fy=0.1, interpolation=cv2.INTER_NEAREST)img3 = cv2.resize(img2,(0,0),fx=2,fy=2, interpolation=cv2.INTER_NEAREST)cv2.imshow('img0',img0)cv2.imshow('img1',img1)cv2.imshow('img2',img2)cv2.imshow('img3',img3)while (True): if cv2.waitKey(0) == 27: breakcv2.destroyAllWindows()]]></content>
  </entry>
  <entry>
    <title><![CDATA[OpenCV-Python小白进阶之位运算与掩膜]]></title>
    <url>%2F2019%2F08%2F18%2FOpenCV-Python%E5%B0%8F%E7%99%BD%E8%BF%9B%E9%98%B6%E4%B9%8B%E4%BD%8D%E8%BF%90%E7%AE%97%E4%B8%8E%E6%8E%A9%E8%86%9C%2F</url>
    <content type="text"><![CDATA[OpenCV-Python小白进阶之位运算与掩膜位运算 由于图片是有一个个0和1组成的，所以OpenCV中对图像也支持为运算（与或非等） 1234dst = cv2.bitwise_and(src1，src2[，dst[，mask]])dst = cv2.bitwise_not(src[, dst[, mask]])dst = cv2.bitwise_or(src1, src2[, dst[, mask]])dst = cv2.bitwise_xor(src1, src2[, dst[, mask]]) bitwise_and是对二进制数据进行“与”操作，即对图像（灰度图像或彩色图像均可）每个像素值进行二进制“与”操作，1&1=1，1&0=0，0&1=0，0&0=0 bitwise_or是对二进制数据进行“或”操作，即对图像（灰度图像或彩色图像均可）每个像素值进行二进制“或”操作，1|1=1，1|0=0，0|1=0，0|0=0 bitwise_xor是对二进制数据进行“异或”操作，即对图像（灰度图像或彩色图像均可）每个像素值进行二进制“异或”操作，1^1=0,1^0=1,0^1=1,0^0=0 bitwise_not是对二进制数据进行“非”操作，即对图像（灰度图像或彩色图像均可）每个像素值进行二进制“非”操作，1=0，0=1 123456789101112131415161718192021222324252627282930313233import numpy as npimport cv2img = cv2.imread('cv.jpg')# cv2.imshow('image',img)rectangle = np.zeros(img.shape[0:2], dtype='uint8')cv2.rectangle(rectangle, (25, 25), (275, 275), 255, -1)cv2.imshow('rectangle', rectangle)circle = np.zeros(img.shape[0:2], dtype='uint8')cv2.circle(circle, (150, 150), 150, 255, -1)cv2.imshow('circle', circle)bit_and = cv2.bitwise_and(rectangle, circle)cv2.imshow('and', bit_and)bit_or = cv2.bitwise_or(rectangle, circle)cv2.imshow('or', bit_or)bit_xor = cv2.bitwise_xor(rectangle, circle)cv2.imshow('xor', bit_xor)bit_not1 = cv2.bitwise_not(rectangle)cv2.imshow('not1', bit_not1)bit_not2 = cv2.bitwise_not(circle)cv2.imshow('not2', bit_not2)while (True): if cv2.waitKey(0)==27: breakcv2.destroyAllWindows() 掩膜用选定的图像、图形或物体，对处理的图像（全部或局部）进行遮挡，来控制图像处理的区域或处理过程。用于覆盖的特定图像或物体称为掩模或模板。光学图像处理中,掩模可以是胶片、滤光片等。数字图像处理中,掩模为二维矩阵数组,有时也用多值图像。 数字图像处理中，图像掩模主要用于： ①提取感兴趣区,用预先制作的感兴趣区掩模与待处理图像相乘,得到感兴趣区图像,感兴趣区内图像值保持不变,而区外图像值都为0。 ②屏蔽作用,用掩模对图像上某些区域作屏蔽,使其不参加处理或不参加处理参数的计算,或仅对屏蔽区作处理或统计。 ③结构特征提取,用相似性变量或图像匹配方法检测和提取图像中与掩模相似的结构特征。 ④特殊形状图像的制作。掩膜是一种图像滤镜的模板，实用掩膜经常处理的是遥感图像。当提取道路或者河流，或者房屋时，通过一个n*n的矩阵来对图像进行像素过滤，然后将我们需要的地物或者标志突出显示出来。这个矩阵就是一种掩膜。 12345678910111213141516171819202122232425import cv2 as cvcv.namedWindow('image', 0)cv.resizeWindow('image', 720, 480)# 加载两张图片img1 = cv.imread('a.jpg')img2 = cv.imread('a.jpeg')# 我想在左上角放置标识，所以我创建了一个ROIrows,cols,channels = img2.shaperoi = img1[0:rows, 0:cols ]# 现在创建一个徽标掩码并创建其反转掩码img2gray = cv.cvtColor(img2,cv.COLOR_BGR2GRAY)ret, mask = cv.threshold(img2gray, 10, 255, cv.THRESH_BINARY)mask_inv = cv.bitwise_not(mask)# 现在使ROI中的徽标区域变黑img1_bg = cv.bitwise_and(roi,roi,mask = mask_inv)# 仅从徽标图像中获取徽标区域。img2_fg = cv.bitwise_and(img2,img2,mask = mask)# 在ROI中放置徽标并修改主图像dst = cv.add(img1_bg,img2_fg)img1[0:rows, 0:cols ] = dstcv.imshow('image',img1)cv.waitKey(0)cv.destroyAllWindows()]]></content>
  </entry>
  <entry>
    <title><![CDATA[OpenCv-Python小白进阶之进度条createTrackbar]]></title>
    <url>%2F2019%2F08%2F17%2FOpenCv-Python%E5%B0%8F%E7%99%BD%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%BF%9B%E5%BA%A6%E6%9D%A1createTrackbar%2F</url>
    <content type="text"><![CDATA[OpenCv-Python小白进阶之进度条createTrackbarcreateTrackbarint createTrackbar(const string&amp; trackbarname, const string&amp;winname, int* value, int count ，TrackbarCallback onChange = 0, void* userdata = 0) 参数1：轨迹条名字 参数2：窗口名字 参数3：滑块初始位置 参数4：表示滑块达到最大位置的值 参数5：默认值为0，指向回调函数 参数6：默认值为0，用户传给回调函数的数据值 getTrackbarint getTrackbarPos(const string&amp; trackbarname, const string&amp; winname) 函数作用： 获取滑动条的位置的值 参数1:进度条名称 参数2:窗口名称 返回值：进度条位置 代码实现12345678910111213141516171819202122# -*- coding:utf-8 -*-import cv2img = cv2.imread('a.jpg', 0)print img.sizeprint img.dtypecv2.namedWindow('image', 0)cv2.resizeWindow('image', 720, 480)cv2.createTrackbar('num','image',0,255,lambda x: None)while(True): num = cv2.getTrackbarPos('num','image') ret, thresh1 = cv2.threshold(img, num, 255, cv2.THRESH_BINARY) cv2.imshow('image', thresh1) if cv2.waitKey(1) == 27: breakcv2.destroyAllWindows()]]></content>
  </entry>
  <entry>
    <title><![CDATA[OpenCV-Python小白进阶之图像固定阈值二值化处理threshold]]></title>
    <url>%2F2019%2F08%2F17%2FOpenCV-Python%E5%B0%8F%E7%99%BD%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%9B%BE%E5%83%8F%E5%9B%BA%E5%AE%9A%E9%98%88%E5%80%BC%E4%BA%8C%E5%80%BC%E5%8C%96%E5%A4%84%E7%90%86threshold%2F</url>
    <content type="text"><![CDATA[OpenCV-Python小白进阶之图像固定阈值二值化处理threshold二值化定义：图像的二值化，就是将图像上的像素点的灰度值设置为0或255，也就是将整个图像呈现出明显的只有黑和白的视觉效果。灰度值0：黑，灰度值255：白 一幅图像包括目标物体、背景还有噪声，要想从多值的数字图像中直接提取出目标物体，常用的方法就是设定一个阈值T，用T将图像的数据分成两部分：大于T的像素群和小于T的像素群。这是研究灰度变换的最特殊的方法，称为图像的二值化（Binarization）。 threshold cv2.threshold(img, threshold, maxval,type) 其中： threshold是设定的阈值 maxval是当灰度值大于（或小于）阈值时将该灰度值赋成的值 type规定的是当前二值化的方式 代码实现123456789101112131415161718192021222324# -*- coding:utf-8 -*-import cv2img1 = cv2.imread('opencv.png', cv2.IMREAD_GRAYSCALE)# cv2.THRESH_OTSU 作为图像自适应二值化的一个很优的算法Otsu大津算法的参数ret, binary = cv2.threshold(img1, 175, 255, cv2.THRESH_BINARY)# cv2.THRESH_BINARY 大于阈值的部分被置为255，小于部分被置为0ret, binaryinv = cv2.threshold(img1, 175, 255, cv2.THRESH_BINARY_INV)# cv2.THRESH_BINARY_INV 大于阈值部分被置为0，小于部分被置为255ret, trunc = cv2.threshold(img1, 175, 255, cv2.THRESH_TRUNC)# cv2.THRESH_TRUNC 大于阈值部分被置为threshold，小于部分保持原样ret, tozero = cv2.threshold(img1, 175, 255, cv2.THRESH_TOZERO)# cv2.THRESH_TOZERO 小于阈值部分被置为0，大于部分保持不变ret, tozeroinv = cv2.threshold(img1, 175, 255, cv2.THRESH_TOZERO_INV)# cv2.THRESH_TOZERO_INV 大于阈值部分被置为0，小于部分保持不变while True: cv2.imshow('img1', img1) cv2.imshow('binary', binary) cv2.imshow('binaryinv', binaryinv) cv2.imshow('trunc', trunc) cv2.imshow('tozero', tozero) cv2.imshow('tozeroinv', tozeroinv) if cv2.waitKey(1) == 27: break]]></content>
  </entry>
  <entry>
    <title><![CDATA[OpenCV-Python小白进阶之获取像素点]]></title>
    <url>%2F2019%2F08%2F16%2FOpenCV-Python%E5%B0%8F%E7%99%BD%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%8E%B7%E5%8F%96%E5%83%8F%E7%B4%A0%E7%82%B9%2F</url>
    <content type="text"><![CDATA[OpenCV-Python小白进阶之获取像素点灰度图因为灰度图不具有RGB值，所以的img是一个二维数组，第一维表示行，第二维表示列 代码实现 12print img.shapeprint img[1][1] 彩色图因为彩色图具有RGB值，所以的img是一个三维数组，第一维表示行，第二维表示列，第三维表示RGB通道,0表示b，1表示g，2表示r 代码实现12print img.shapeprint img[1][1][1]]]></content>
  </entry>
  <entry>
    <title><![CDATA[OpenCV-Python小白进阶之灰度转化、分离RGB与直方图显示]]></title>
    <url>%2F2019%2F08%2F15%2FOpenCV-Python%E5%B0%8F%E7%99%BD%E8%BF%9B%E9%98%B6%E4%B9%8B%E7%81%B0%E5%BA%A6%E8%BD%AC%E5%8C%96%E3%80%81%E5%88%86%E7%A6%BBRGB%E4%B8%8E%E7%9B%B4%E6%96%B9%E5%9B%BE%E6%98%BE%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[OpenCV-Python小白进阶之灰度转化、分离RGB与直方图显示@[toc] 条件环境：OpenCV Pycharm python3.7素材： 转化为灰度图函数： cv2.imread(path) 载入图片 cv2.cvtColor(img, cv2.COLOR_RGB2GRAY) 把img图片从RGB格式切换为GRAY cv2.namedWindow(name, aotusize) 给窗口命名，大小不可自由调整 cv2.resizeWindow(name, length, width) 给窗口设置长与宽 cv2.imshow(name, img) 显示img图片 cv2.imwrite(path, img) 创建path路径并写入img图片 代码实现123456789import cv2img = cv2.imread('p1.jpg')img0 = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)cv2.imwrite('p2.jpg', img0)cv2.namedWindow('figure1', 0)cv2.resizeWindow('figure1', 960, 480)cv2.imshow('figure1', img0) 输出 分离RGB函数 cv2.split(img) 分离img图片的RGB，注意！！！电脑是以BGR的顺序分离的 代码实现123456789101112131415161718192021222324import cv2import matplotlib.pyplot as pltimg = cv2.imread('p1.jpg')img0 = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)cv2.imwrite('p2.jpg', img0)cv2.namedWindow('figure1', 0)cv2.resizeWindow('figure1', 960, 480)cv2.imshow('figure1', img0)for col in ['Blue', "Green", 'Red']: cv2.namedWindow(col, 0) cv2.resizeWindow(col, 960, 480)b, g, r = cv2.split(img)cv2.imwrite('Blue.jpg', b)cv2.imwrite('Red.jpg', r)cv2.imwrite('Green.jpg', g)cv2.imwrite('Blue.jpg', b)cv2.imwrite('Red.jpg', r)cv2.imwrite('Green.jpg', g)cv2.destroyAllWindows() 输出redblueGreen 直方图显示函数 cv2.calcHist(images, channels, mask, histSize, ranges[, hist[, accumulate ]]) 第一个参数必须用方括号括起来。 第二个参数是用于计算直方图的通道，这里使用灰度图计算直方图，所以就直接使用第一个通道； 第三个参数是Mask，这里没有使用，所以用None。 第四个参数是histSize，表示这个直方图分成多少份（即多少个直方柱）。第二个例子将绘出直方图，到时候会清楚一点。 第五个参数是表示直方图中各个像素的值，[0.0, 256.0]表示直方图能表示像素值从0.0到256的像素。 代码实现12345678910111213141516171819202122232425262728293031323334353637import cv2import matplotlib.pyplot as pltimg = cv2.imread('p1.jpg')img0 = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)cv2.imwrite('p2.jpg', img0)cv2.namedWindow('figure1', 0)cv2.resizeWindow('figure1', 960, 480)cv2.imshow('figure1', img0)for col in ['Blue', "Green", 'Red']: cv2.namedWindow(col, 0) cv2.resizeWindow(col, 960, 480)b, g, r = cv2.split(img)cv2.imwrite('Blue.jpg', b)cv2.imwrite('Red.jpg', r)cv2.imwrite('Green.jpg', g)r = cv2.imshow("Red", r)g = cv2.imshow("Green", g)b = cv2.imshow("Blue", b)cv2.destroyAllWindows()color = ['b', 'g', 'r']for i, col in enumerate(color): histr = cv2.calcHist([img], [i], None, [256], [0, 256]) plt.plot(histr, color=col) plt.xlim(0, 256) plt.ylim(0, 700000) plt.show()histr = cv2.calcHist([img0], [0], None, [256], [0, 256])plt.plot(histr, color=col)plt.xlim(0, 256)plt.ylim(0, 700000)plt.show() 输出]]></content>
  </entry>
  <entry>
    <title><![CDATA[浅谈减而治之与分而治之]]></title>
    <url>%2F2019%2F08%2F12%2F%E6%B5%85%E8%B0%88%E5%87%8F%E8%80%8C%E6%B2%BB%E4%B9%8B%E4%B8%8E%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B%2F</url>
    <content type="text"><![CDATA[浅谈减而治之与分而治之@[toc] 减而治之线性递归（linear recursion）即减而治之（decrease-and-conquer）的思想：递归每深入一层，待求解问题的规模都缩减一个常数，直至最终蜕化为平凡的小（简单）问题。将一个规模为n的大问题退化为一个规模为n-1的小问题，直至退化为规模为1的平凡情况，这种情况称之为递归基（base case of recursion），当达到递归基时,算法将执行非递归计算。这一方法体现了算法的有穷性。一般这种问题可以分为两个独立的子问题，其一用于单独的一个元素（如：递归出口），其二应用于剩余部分结构与原问题相同。子问题经合并后为原问题的解。 1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;int Fib(int n)&#123; if (n==1||n==0) &#123; return 1;//递归出口 &#125; else &#123; return Fib(n-1)+Fib(n-2);//把问题分解成Fib(n-1)+Fib(n-2)来递归求解 &#125;&#125;int main()&#123; int n; cin&gt;&gt;n; cout&lt;&lt;Fib(n)&lt;&lt;endl; return 0;&#125; 分而治之二分递归（binary recursion）即分而治之（divide-and-conquer）的思想：将其分解为若干规模更小的子问题， 再通过递归机制分别求解。 这种分解持续进行，直到子问题规模缩减至平凡情况。在这种情况下，每一递归实例会调用多个递归来完成，故称作多路递归（multi-way recursion），通常都是将原问题一分为二，故有二分递归。以下代码是对数组求和的二分递归的实现，新算法的思路是：以居中的元素为界将数组一分为二；递归地对子数组分别求和；最后，子数组之和相加即为原数组的总和。 可以用二路归并来理解下面以vector的二路归并为例 123456789101112131415161718192021222324252627282930313233343536373839template &lt;typename T&gt;void Vector&lt;T&gt;::mergeSort(Rank lo, Rank hi)&#123; if (hi-lo&lt;2) &#123; return; &#125; int mi=(lo+hi)&gt;&gt;2; mergeSort(lo, mi); mergeSort(mi, hi); merge(lo, mi, hi);&#125;template &lt;typename T&gt;void Vector&lt;T&gt;::merge(Rank lo, Rank mi, Rank hi)&#123; T* A=_elem+lo; int lb=mi-lo; T* B=new T[lb]; for (Rank i=0; i&lt;lb; i++) &#123; B[i]=A[i]; &#125; int lc=hi-mi; T* C=_elem+mi; for (Rank i=0,j=0,k=0; j&lt;lb;i++ ) &#123; if ((lc&lt;=k)||(B[j]&lt;=C[k])) &#123; A[i]=B[j++]; &#125; if ((k&lt;lc)&amp;&amp;(C[k]&lt;B[j])) &#123; A[i]=C[k++]; &#125; &#125; delete [] B;&#125; 大致内容如图所示：二路归并的意义在于把一个无序的向量分解成单个有序的元素，然后两两归并排序成为一个有序的向量，所以可以递归。二路归并体现了分而治之的思想。把一个向量一分为二，慢慢的变成单个的元素将问题缩减成很简单的情况。然后排序归并。 参考链接：https://juejin.im/post/5b9f8ffae51d450e83776059]]></content>
  </entry>
  <entry>
    <title><![CDATA[C++多重继承的构造与析构的顺序]]></title>
    <url>%2F2019%2F08%2F12%2FC-%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E7%9A%84%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84%E7%9A%84%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[C++多重继承的构造与析构的次序在C++的多重继承中含有虚基类，成员对象时很容易把构造与析构的顺序弄不清楚 下面看一段代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;iostream&gt;using namespace std;class OBJ1&#123;public: OBJ1() &#123; cout&lt;&lt;"OBJ1"&lt;&lt;endl; &#125; ~OBJ1() &#123; cout&lt;&lt;"~OBJ1"&lt;&lt;endl; &#125;&#125;;class OBJ2&#123;public: OBJ2() &#123; cout&lt;&lt;"OBJ2"&lt;&lt;endl; &#125; ~OBJ2() &#123; cout&lt;&lt;"~OBJ2"&lt;&lt;endl; &#125;&#125;;class Base1&#123;public: Base1() &#123; cout&lt;&lt;"Base1"&lt;&lt;endl; &#125; ~Base1() &#123; cout&lt;&lt;"~Base1"&lt;&lt;endl; &#125;&#125;;class Base2&#123;public: Base2() &#123; cout&lt;&lt;"Base2"&lt;&lt;endl; &#125; ~Base2() &#123; cout&lt;&lt;"~Base2"&lt;&lt;endl; &#125;&#125;;class Base3&#123;public: Base3() &#123; cout&lt;&lt;"Base3"&lt;&lt;endl; &#125; ~Base3() &#123; cout&lt;&lt;"~Base3"&lt;&lt;endl; &#125;&#125;;class Base4&#123;public: Base4() &#123; cout&lt;&lt;"Base4"&lt;&lt;endl; &#125; ~Base4() &#123; cout&lt;&lt;"~Base4"&lt;&lt;endl; &#125;&#125;;class Derived: public Base1, virtual public Base2, public Base3, virtual public Base4&#123;public: Derived():Base4(),Base3(),Base2(),Base1(),obj2(),obj1()&#123;&#125;protected: OBJ1 obj1; OBJ2 obj2;&#125;;int main()&#123; Derived aa; return 0;&#125; 运行结果 12345678910111213Base2Base4Base1Base3OBJ1OBJ2~OBJ2~OBJ1~Base3~Base1~Base4~Base2Program ended with exit code: 0 由此可知C++中多重继承的构造顺序是1）虚函数优先构造，其顺序是按那个继承的顺序来的，而不是按初始化列表来的2）然后构造普通的基类，其顺序也是按那个继承的顺序来的，不是按初始化列表来的3）最后构造成员对象4）构造派生类自己的函数体 由此可知C++中多重继承的析构顺序是1）构造派生类自己的函数体2）析造成员对象3）然后析构普通的基类，其顺序也是按那个继承的顺序来的，也不是按初始化列表来的4）最后是那个虚基类]]></content>
  </entry>
  <entry>
    <title><![CDATA[析构函数为虚函数]]></title>
    <url>%2F2019%2F08%2F12%2F%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[转载 https://blog.csdn.net/zhangqk2016/article/details/51849535 多态是面向对象的一个基本属性，包括静态多态（编译阶段）和动态多态（运行阶段），静态多态主要是指函数参数不同产生的多态性，是在编译阶段可以识别的一种多态机制，而运行时多态则主要用于基类指针指向派生类对象时，可以通过基类指针直接调用派生类的对象函数，当然这种多态是通过虚函数实现的。 虚函数的目的就是通知系统在函数调用时能够自动识别对应的类对象类型，从而能够根据指针所指类型调用对应的类对象，实现函数调用时的多态性。对于析构函数而言，同样适用于上述规则。如果析构函数不是虚函数，那么在调用该函数时（对象被删除时）则只会调用当前对象对应的类的析构函数，这对于直接定义的对象是没有什么影响的，但是对于使用基类指向派生类的指针而言，因为基类指针实际上是基类类型，所以析构时自然只会调用基类的析构函数，这就可能产生内存泄漏（因为派生类的析构函数不被调用）。所以如果确定程序中有基类指针指向派生类的问题，则必须将基类的析构函数指定为虚函数，如此才能确保NEW出来的对象被正确的DELETE。 以下是几个示例程序，用于方便理解： 123456789101112131415161718class ClxBase&#123; public: ClxBase() &#123;&#125;; ~ClxBase() &#123; cout &lt;&lt; "Output from the destructor of class ClxBase!" &lt;&lt; endl; &#125;; void DoSomething() &#123; cout &lt;&lt; "Do something in class ClxBase!" &lt;&lt; endl; &#125;; &#125;; class ClxDerived : public ClxBase&#123; public: ClxDerived() &#123;&#125;; ~ClxDerived() &#123; cout &lt;&lt; "Output from the destructor of class ClxDerived!" &lt;&lt; endl; &#125;; void DoSomething() &#123; cout &lt;&lt; "Do something in class ClxDerived!" &lt;&lt; endl; &#125;; &#125;; 示例程序一： 123456789int main()&#123; ClxBase base; ClxDerived derived; base.DoSomething(); derived.DoSomething(); return 0; &#125; 运行结果： Do something in class ClxBase! Do something in class ClxDerived! Output from the destructor of class ClxDerived! Output from the destructor of class ClxBase! Output from the destructor of class ClxBase!分析： 从以上实例程序可以发现，正常构造的对象，派生类的析构函数会主动调用基类的析构函数，所以不会存在内存泄漏问题。 示例程序二： 123456int main()&#123; ClxDerived *p = new ClxDerived; p-&gt;DoSomething(); delete p; return 0; &#125; 运行结果： Do something in class ClxDerived! Output from the destructor of class ClxDerived! Output from the destructor of class ClxBase!分析：从以上结果可以发现，派生类的指针在析构时，同样是运行指针所对应类型的派生类的析构函数，而此析构函数自然会调用基类的析构函数，所以也不会产生内存泄漏。 实例程序三： 123456int main()&#123; ClxBase *p = new ClxDerived; p-&gt;DoSomething(); delete p; return 0; &#125; 运行结果： Do something in class ClxBase! Output from the destructor of class ClxBase!分析： 从以上结果可以发现，基类指针在析构时，会调用基类的析构函数，纵然其指向派生类，但其依然会调用基类的析构，所以派生类中如有需要释放的内存空间，则必然得不到释放，从而产生内存泄漏。 示例程序四： 1234567891011121314151617181920class ClxBase&#123; public: ClxBase() &#123;&#125;; virtual ~ClxBase() &#123;cout &lt;&lt; "Output from the destructor of class ClxBase!" &lt;&lt; endl;&#125;; virtual void DoSomething() &#123; cout &lt;&lt; "Do something in class ClxBase!" &lt;&lt; endl; &#125;; &#125;; class ClxDerived : public ClxBase&#123; public: ClxDerived() &#123;&#125;; ~ClxDerived() &#123; cout &lt;&lt; "Output from the destructor of class ClxDerived!" &lt;&lt; endl; &#125;; void DoSomething() &#123; cout &lt;&lt; "Do something in class ClxDerived!" &lt;&lt; endl; &#125;; &#125;; int main()&#123; ClxBase *p = new ClxDerived; p-&gt;DoSomething(); delete p; return 0; &#125; 运行结果： Do something in class ClxDerived! Output from the destructor of class ClxDerived! Output from the destructor of class ClxBase!分析： 以上结果可以发现，不管是普通成员函数还是析构函数，只有定义为虚函数，才能够在基类指针指向派生类对象时调用所指向对象的响应函数，从而在函数析构时能够正确的delete掉new出来的对象，不产生内存泄漏。]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于虚函数与纯虚函数的几点小记]]></title>
    <url>%2F2019%2F08%2F12%2F%E5%85%B3%E4%BA%8E%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%87%A0%E7%82%B9%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[关于虚函数与纯虚函数的几点虚函数虚函数的关键字是virtual虚函数是提供一种“推迟联编”或者“动态联编”的功能，来实现多态性，形成虚指针。虚函数的调用并不是在编译时刻被确定的，而是在运行时刻被确定的。 一个代码示列： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;using namespace std;class Base1&#123;public: virtual void display()const;&#125;;void Base1::display()const&#123; cout&lt;&lt;"Base1::display()"&lt;&lt;endl;&#125;class Base2:public Base1&#123;public: void display()const;&#125;;void Base2::display()const&#123; cout&lt;&lt;"Base2::display()"&lt;&lt;endl;&#125;class Derived:public Base1&#123;public: void display()const;&#125;;void Derived::display()const&#123; cout&lt;&lt;"Derived::display()"&lt;&lt;endl;&#125;void fun(Base1 *ptr)&#123; ptr-&gt;display();&#125;int main()&#123; Base1 base1; Base2 base2; Derived derived; fun(&amp;base1); fun(&amp;base2); fun(&amp;derived); return 0;&#125; 运行结果： 1234Base1::display()Base2::display()Derived::display()Program ended with exit code: 0 纯虚函数纯虚函数是在基类中声明的虚函数，它在基类中没有定义，所以不能实例化不能产生对象。在基类中实现纯虚函数的方法是在函数原型后加“=0” virtual void funtion1()=0其中虚函数的主要作用是：使基类中的纯虚函数仅仅只是继承函数的一个接口。其中含有纯虚函数的类被称为抽象类，若抽象类在继承中纯虚函数还是没有被实现则还是抽象类抽象类的作用：产生一个接口被派生类继承 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;class Base1&#123;public: virtual void display() const=0;&#125;;class Base2:public Base1&#123;public: void display() const;&#125;;void Base2::display()const&#123; cout&lt;&lt;"Base2::display()"&lt;&lt;endl;&#125;class Derived:public Base2&#123;public: void display()const;&#125;;void Derived::display()const&#123; cout&lt;&lt;"Derivd::display()"&lt;&lt;endl;&#125;void fun(Base1 *ptr)&#123; ptr-&gt;display();&#125;int main()&#123; Base2 base2; Derived derived; fun(&amp;base2); fun(&amp;derived); return 0;&#125; 运行结果 123Base2::display()Derivd::display()Program ended with exit code: 0 详情请看 https://blog.csdn.net/wang13342322203/article/details/80512330]]></content>
  </entry>
  <entry>
    <title><![CDATA[浅谈Python多进程与多线程]]></title>
    <url>%2F2019%2F08%2F12%2F%E6%B5%85%E8%B0%88Python%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[浅谈Python多进程与多线程@[toc] 什么是进程，什么是线程进程进程是程序的一次动态执行过程，它对应了从代码加载、执行到执行完毕的一个完整过程。进程是资源分配的最小单位，进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵一个进程若不存在多线程则相当于线程 线程线程是程序执行的最小单位，每个线程中可以实现资源的共享、通信等操作， 但线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。 两者的区别 进程 线程 相同点 两者都是实现多个任务同时运行的方式 不同点 进程拥有独立的资源，进程间相互独立，互不打扰，但线程之间更容易实现共享，同时多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。 多进程在Unix与Linux中系统支持fork()，但在我们常见的系统中不容许Windows可以使用，但Mac OS X与Linux可以使用,但Python是一门可以跨平台的编程语言，对任意系统都支持multiprocessing 其中：os.getpid() 获取当前进程的PID号os.getppid() 获取当前进程父进程的PID号 代码实现Mac OS X下使用fork（）创建子进程fork()语法： 功能：为当前进程创建一个子进程 参数：无 返回值：0 和 子进程PID（在父进程中） &lt; 0 子进程创建失败 = 0 在子进程中的返回值 &gt; 0 在父进程中的返回值 fork()很特殊，它是一个调用一次，返回两次的函数子进程永远返回0，而父进程返回子进程的ID,所以一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用getppid()就可以拿到父进程的ID。 12345678910111213# -*- coding:utf-8 -*-#！usr/bin/env pythonimport os# fork()属于系统内建函数，需从OS模块引入print 'process (%s) strat...' %os.getpid()pid = os.fork()# 调用一次，返回两次if pid == 0:# 判断是否为子进程 print "I'm child process (%s) and my parent is %s" %(os.getpid(),os.getppid())else: print "I (%s) just created a child process (%s)." %(os.getpid(),pid) 输出 123process (58196) strat...I (58196) just created a child process (58198).I&apos;m child process (58198) and my parent is 58196 使用multiprocessing由于windows不可以使用fork（），但python为所有操作系统准备了multiprocess供它们创建子线程 创建子进程时，只需要传入一个执行函数和函数的参数，创建一个Process实例，用start()方法启动，这样创建进程比fork()还要简单。join()方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。 1234567891011121314151617181920212223# -*- coding:utf-8 -*-#！usr/bin/env pythonfrom multiprocessing import Process# 从multiprocessing模块引入Processimport osdef fun(name): print 'Run child process %s(%s)...'%(name,os.getpid()) # 打印当前进程if __name__=='__main__': # 若在本模块运行时 print 'Parent process %s.'%os.getpid() # 打印父进程 p = Process(target=fun,args=('test',)) # 创建一个子进程 print 'Process will start.' p.start() # 开始运行子进程 p.join() # 停止运行子进程 print 'Process end' 输出 1234Parent process 61028.Process will start.Run child process test(61029)...Process end 进程池如果要启动大量的子进程，可以用进程池的方式批量创建子进程： 关键字为poll，Pool的默认大小是CPU的核数；但它也可以设置参数如果为pool（5）则是申请有5个子进程的进程池注意：对Pool对象调用join()方法会等待所有子进程执行完毕，调用join()之前必须先调用close()，调用close()之后就不能继续添加新的Process了。 12345678910111213141516171819202122232425# -*- coding:utf-8 -*-#！usr/bin/env pythonfrom multiprocessing import Pool# 从multiprocess模块引入Poolimport os,time,randomdef long_time_task(name): print 'Run task%s(%s)' % (name, os.getpid()) start = time.time() time.sleep(random.random()*3) # random.random（）产生一个0～1的随机数 end = time.time() print 'Task %s runs %0.2f seconds' % (name, (end-start)) # 输出任务名与运行时间差 if __name__ == '__main__': print 'Parent process %s.' % os.getpid() p = Pool() # 生成一个进程池 for i in range(5): p.apply_async(long_time_task, args=(i,)) print 'Waiting for all subprocesses done...' p.close() p.join() print 'All subprocess done' 输出 1234567891011121314Parent process 66221.Waiting for all subprocesses done...Run task0(66223)Run task1(66224)Run task2(66225)Run task3(66226)Task 1 runs 0.69 secondsRun task4(66224)Task 4 runs 0.91 secondsTask 2 runs 1.97 secondsTask 3 runs 2.19 secondsTask 0 runs 3.00 secondsAll subprocess done3.03261709213 因为我使用的是4核处理器，所以task 4要等待前面某个task完成后才执行 多进程的通信multiprocessing.Queue()Queue是多进程安全的队列，可以使用Queue实现多进程之间的数据传递。put方法用以插入数据到队列中，put方法还有两个可选参数：blocked和timeout。如果blocked为True（默认值），并且timeout为正值，该方法会阻塞timeout指定的时间，直到该队列有剩余的空间。如果超时，会抛出Queue.Full异常。如果blocked为False，但该Queue已满，会立即抛出Queue.Full异常。 get方法可以从队列读取并且删除一个元素。同样，get方法有两个可选参数：blocked和timeout。如果blocked为True（默认值），并且timeout为正值，那么在等待时间内没有取到任何元素，会抛出Queue.Empty异常。如果blocked为False，有两种情况存在，如果Queue有一个值可用，则立即返回该值，否则，如果队列为空，则立即抛出Queue.Empty异常 以Queue为例，在父进程中创建两个子进程，一个往Queue里写数据，一个从Queue里读数据： ==multiprcessing.Queue.put() 为 入队操作== ==multiprcessing.Queue.get() 为 出队操作== 1234567891011121314151617181920212223242526# -*- coding:utf-8 -*-#！usr/bin/env pythonimport multiprocessingdef writer_proc(q): try: q.put(1, block = False) except: pass def reader_proc(q): try: print q.get(block = False) except: passif __name__ == "__main__": q = multiprocessing.Queue() writer = multiprocessing.Process(target=writer_proc, args=(q,)) writer.start() reader = multiprocessing.Process(target=reader_proc, args=(q,)) reader.start() reader.join() writer.join() multiprocessing.Pipe()Pipe方法返回(conn1, conn2)代表一个管道的两个端。Pipe方法有duplex参数，如果duplex参数为True(默认值)，那么这个管道是全双工模式，也就是说conn1和conn2均可收发。duplex为False，conn1只负责接受消息，conn2只负责发送消息。 send和recv方法分别是发送和接受消息的方法。例如，在全双工模式下，可以调用conn1.send发送消息，conn1.recv接收消息。如果没有消息可接收，recv方法会一直阻塞。如果管道已经被关闭，那么recv方法会抛出EOFError。 1234567891011121314151617181920212223242526272829303132# -*- coding:utf-8 -*-#！usr/bin/env pythonimport multiprocessingimport timedef proc1(pipe): while True: for i in range(10): print "send: %s" %(i) pipe.send(i) # 向pipe中发送i值 time.sleep(1)def proc2(pipe): while True: print "proc2 rev:", pipe.recv() # 接受i值 time.sleep(1)if __name__ == "__main__": pipe = multiprocessing.Pipe() # 申请一个pipe p1 = multiprocessing.Process(target=proc1, args=(pipe[0],)) p2 = multiprocessing.Process(target=proc2, args=(pipe[1],)) # 生成两个子进程p1，p2 p1.start() p2.start() # 开始执行进程 p1.join() p2.join() # 结束进程 多线程Python的标准库提供了两个模块：thread和threading，thread是低级模块，threading是高级模块，对thread进行了封装。绝大多数情况下，我们只需要使用threading这个高级模块。 代码实现 单线程 1234567891011121314151617#-*- coding:utf-8 -*-#！usr/bin/env pythonimport timedef fun1(): for i in range(3): print '我在看书',time.ctime() time.sleep(1)def fun2(): for i in range(3): print "我在听歌",time.ctime() time.sleep(1)fun1()fun2() 输出 123456我在看书 Fri Aug 9 22:34:41 2019我在看书 Fri Aug 9 22:34:42 2019我在看书 Fri Aug 9 22:34:43 2019我在听歌 Fri Aug 9 22:34:44 2019我在听歌 Fri Aug 9 22:34:45 2019我在听歌 Fri Aug 9 22:34:46 2019 多线程输出 1234567891011121314151617181920212223242526#-*- coding:utf-8 -*-#！usr/bin/env pythonimport timeimport threadingdef fun1(): for i in range(3): print '我在看书',time.ctime() time.sleep(1)def fun2(): for i in range(3): print "我在听歌",time.ctime() time.sleep(1)p1 = threading.Thread(target=fun1)# 创建一个线程p1p2 = threading.Thread(target=fun2)# 创建一个线程p2p1.start()p2.start()# 执行线程p1.join()p2.join()# 结束线程 123456我在看书 Fri Aug 9 22:37:44 2019我在听歌 Fri Aug 9 22:37:44 2019我在看书 Fri Aug 9 22:37:45 2019我在听歌 Fri Aug 9 22:37:45 2019我在听歌 Fri Aug 9 22:37:46 2019我在看书 Fri Aug 9 22:37:46 2019 线程通信由于线程通信造成的混乱多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了 1234567891011121314151617181920#-*- coding:utf-8 -*-#！usr/bin/env pythonimport timeimport threadingcount = 5def fun(n): global count for i in range(5): count += n time.sleep(1) count -= n print countp1 = threading.Thread(target=fun,args=(5,))p2 = threading.Thread(target=fun,args=(3,))p1.start()p2.start() 输出 123456789105 810810858105 解决方案在Python中提供了关键字lock来防止由于线程通信造成的混乱。由于锁（lock）只有一个，无论多少线程，同一时刻最多只有一个线程持有该锁，所以，不会造成修改的冲突。所以获得lock的线程将会优先执行。所以lock会使各个线程依次执行。但使用lock时，threading.Lock()，要注意获取和释放锁， lock.acquire()、 lock.release() 示例代码： 1234567891011121314151617181920212223242526272829303132#-*- coding:utf-8 -*-#！usr/bin/env pythonimport threadingdef fun1(): global A, lock lock.acquire() for i in range(10): A += 1 print "Thread-1", A lock.release()def fun2(): global A, lock lock.acquire() for i in range(10): A += 10 print "Thread-2", A lock.release()if __name__ == '__main__': lock = threading.Lock() A = 0 t1 = threading.Thread(target=fun1) t2 = threading.Thread(target=fun2) t1.start() t2.start() t1.join() t2.join() 输出 1234567891011121314151617181920Thread-1 1Thread-1 2Thread-1 3Thread-1 4Thread-1 5Thread-1 6Thread-1 7Thread-1 8Thread-1 9Thread-1 10Thread-2 20Thread-2 30Thread-2 40Thread-2 50Thread-2 60Thread-2 70Thread-2 80Thread-2 90Thread-2 100Thread-2 110]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F08%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
