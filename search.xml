<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C++多重继承的构造与析构的顺序]]></title>
    <url>%2F2019%2F08%2F12%2FC-%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E7%9A%84%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84%E7%9A%84%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[C++多重继承的构造与析构的次序在C++的多重继承中含有虚基类，成员对象时很容易把构造与析构的顺序弄不清楚 下面看一段代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;iostream&gt;using namespace std;class OBJ1&#123;public: OBJ1() &#123; cout&lt;&lt;"OBJ1"&lt;&lt;endl; &#125; ~OBJ1() &#123; cout&lt;&lt;"~OBJ1"&lt;&lt;endl; &#125;&#125;;class OBJ2&#123;public: OBJ2() &#123; cout&lt;&lt;"OBJ2"&lt;&lt;endl; &#125; ~OBJ2() &#123; cout&lt;&lt;"~OBJ2"&lt;&lt;endl; &#125;&#125;;class Base1&#123;public: Base1() &#123; cout&lt;&lt;"Base1"&lt;&lt;endl; &#125; ~Base1() &#123; cout&lt;&lt;"~Base1"&lt;&lt;endl; &#125;&#125;;class Base2&#123;public: Base2() &#123; cout&lt;&lt;"Base2"&lt;&lt;endl; &#125; ~Base2() &#123; cout&lt;&lt;"~Base2"&lt;&lt;endl; &#125;&#125;;class Base3&#123;public: Base3() &#123; cout&lt;&lt;"Base3"&lt;&lt;endl; &#125; ~Base3() &#123; cout&lt;&lt;"~Base3"&lt;&lt;endl; &#125;&#125;;class Base4&#123;public: Base4() &#123; cout&lt;&lt;"Base4"&lt;&lt;endl; &#125; ~Base4() &#123; cout&lt;&lt;"~Base4"&lt;&lt;endl; &#125;&#125;;class Derived: public Base1, virtual public Base2, public Base3, virtual public Base4&#123;public: Derived():Base4(),Base3(),Base2(),Base1(),obj2(),obj1()&#123;&#125;protected: OBJ1 obj1; OBJ2 obj2;&#125;;int main()&#123; Derived aa; return 0;&#125; 运行结果 12345678910111213Base2Base4Base1Base3OBJ1OBJ2~OBJ2~OBJ1~Base3~Base1~Base4~Base2Program ended with exit code: 0 由此可知C++中多重继承的构造顺序是1）虚函数优先构造，其顺序是按那个继承的顺序来的，而不是按初始化列表来的2）然后构造普通的基类，其顺序也是按那个继承的顺序来的，不是按初始化列表来的3）最后构造成员对象4）构造派生类自己的函数体 由此可知C++中多重继承的析构顺序是1）构造派生类自己的函数体2）析造成员对象3）然后析构普通的基类，其顺序也是按那个继承的顺序来的，也不是按初始化列表来的4）最后是那个虚基类]]></content>
  </entry>
  <entry>
    <title><![CDATA[析构函数为虚函数]]></title>
    <url>%2F2019%2F08%2F12%2F%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[转载 https://blog.csdn.net/zhangqk2016/article/details/51849535 多态是面向对象的一个基本属性，包括静态多态（编译阶段）和动态多态（运行阶段），静态多态主要是指函数参数不同产生的多态性，是在编译阶段可以识别的一种多态机制，而运行时多态则主要用于基类指针指向派生类对象时，可以通过基类指针直接调用派生类的对象函数，当然这种多态是通过虚函数实现的。 虚函数的目的就是通知系统在函数调用时能够自动识别对应的类对象类型，从而能够根据指针所指类型调用对应的类对象，实现函数调用时的多态性。对于析构函数而言，同样适用于上述规则。如果析构函数不是虚函数，那么在调用该函数时（对象被删除时）则只会调用当前对象对应的类的析构函数，这对于直接定义的对象是没有什么影响的，但是对于使用基类指向派生类的指针而言，因为基类指针实际上是基类类型，所以析构时自然只会调用基类的析构函数，这就可能产生内存泄漏（因为派生类的析构函数不被调用）。所以如果确定程序中有基类指针指向派生类的问题，则必须将基类的析构函数指定为虚函数，如此才能确保NEW出来的对象被正确的DELETE。 以下是几个示例程序，用于方便理解： 123456789101112131415161718class ClxBase&#123; public: ClxBase() &#123;&#125;; ~ClxBase() &#123; cout &lt;&lt; "Output from the destructor of class ClxBase!" &lt;&lt; endl; &#125;; void DoSomething() &#123; cout &lt;&lt; "Do something in class ClxBase!" &lt;&lt; endl; &#125;; &#125;; class ClxDerived : public ClxBase&#123; public: ClxDerived() &#123;&#125;; ~ClxDerived() &#123; cout &lt;&lt; "Output from the destructor of class ClxDerived!" &lt;&lt; endl; &#125;; void DoSomething() &#123; cout &lt;&lt; "Do something in class ClxDerived!" &lt;&lt; endl; &#125;; &#125;; 示例程序一： 123456789int main()&#123; ClxBase base; ClxDerived derived; base.DoSomething(); derived.DoSomething(); return 0; &#125; 运行结果： Do something in class ClxBase! Do something in class ClxDerived! Output from the destructor of class ClxDerived! Output from the destructor of class ClxBase! Output from the destructor of class ClxBase!分析： 从以上实例程序可以发现，正常构造的对象，派生类的析构函数会主动调用基类的析构函数，所以不会存在内存泄漏问题。 示例程序二： 123456int main()&#123; ClxDerived *p = new ClxDerived; p-&gt;DoSomething(); delete p; return 0; &#125; 运行结果： Do something in class ClxDerived! Output from the destructor of class ClxDerived! Output from the destructor of class ClxBase!分析：从以上结果可以发现，派生类的指针在析构时，同样是运行指针所对应类型的派生类的析构函数，而此析构函数自然会调用基类的析构函数，所以也不会产生内存泄漏。 实例程序三： 123456int main()&#123; ClxBase *p = new ClxDerived; p-&gt;DoSomething(); delete p; return 0; &#125; 运行结果： Do something in class ClxBase! Output from the destructor of class ClxBase!分析： 从以上结果可以发现，基类指针在析构时，会调用基类的析构函数，纵然其指向派生类，但其依然会调用基类的析构，所以派生类中如有需要释放的内存空间，则必然得不到释放，从而产生内存泄漏。 示例程序四： 1234567891011121314151617181920class ClxBase&#123; public: ClxBase() &#123;&#125;; virtual ~ClxBase() &#123;cout &lt;&lt; "Output from the destructor of class ClxBase!" &lt;&lt; endl;&#125;; virtual void DoSomething() &#123; cout &lt;&lt; "Do something in class ClxBase!" &lt;&lt; endl; &#125;; &#125;; class ClxDerived : public ClxBase&#123; public: ClxDerived() &#123;&#125;; ~ClxDerived() &#123; cout &lt;&lt; "Output from the destructor of class ClxDerived!" &lt;&lt; endl; &#125;; void DoSomething() &#123; cout &lt;&lt; "Do something in class ClxDerived!" &lt;&lt; endl; &#125;; &#125;; int main()&#123; ClxBase *p = new ClxDerived; p-&gt;DoSomething(); delete p; return 0; &#125; 运行结果： Do something in class ClxDerived! Output from the destructor of class ClxDerived! Output from the destructor of class ClxBase!分析： 以上结果可以发现，不管是普通成员函数还是析构函数，只有定义为虚函数，才能够在基类指针指向派生类对象时调用所指向对象的响应函数，从而在函数析构时能够正确的delete掉new出来的对象，不产生内存泄漏。]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于虚函数与纯虚函数的几点小记]]></title>
    <url>%2F2019%2F08%2F12%2F%E5%85%B3%E4%BA%8E%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%87%A0%E7%82%B9%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[关于虚函数与纯虚函数的几点虚函数虚函数的关键字是virtual虚函数是提供一种“推迟联编”或者“动态联编”的功能，来实现多态性，形成虚指针。虚函数的调用并不是在编译时刻被确定的，而是在运行时刻被确定的。 一个代码示列： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;using namespace std;class Base1&#123;public: virtual void display()const;&#125;;void Base1::display()const&#123; cout&lt;&lt;"Base1::display()"&lt;&lt;endl;&#125;class Base2:public Base1&#123;public: void display()const;&#125;;void Base2::display()const&#123; cout&lt;&lt;"Base2::display()"&lt;&lt;endl;&#125;class Derived:public Base1&#123;public: void display()const;&#125;;void Derived::display()const&#123; cout&lt;&lt;"Derived::display()"&lt;&lt;endl;&#125;void fun(Base1 *ptr)&#123; ptr-&gt;display();&#125;int main()&#123; Base1 base1; Base2 base2; Derived derived; fun(&amp;base1); fun(&amp;base2); fun(&amp;derived); return 0;&#125; 运行结果： 1234Base1::display()Base2::display()Derived::display()Program ended with exit code: 0 纯虚函数纯虚函数是在基类中声明的虚函数，它在基类中没有定义，所以不能实例化不能产生对象。在基类中实现纯虚函数的方法是在函数原型后加“=0” virtual void funtion1()=0其中虚函数的主要作用是：使基类中的纯虚函数仅仅只是继承函数的一个接口。其中含有纯虚函数的类被称为抽象类，若抽象类在继承中纯虚函数还是没有被实现则还是抽象类抽象类的作用：产生一个接口被派生类继承 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;class Base1&#123;public: virtual void display() const=0;&#125;;class Base2:public Base1&#123;public: void display() const;&#125;;void Base2::display()const&#123; cout&lt;&lt;"Base2::display()"&lt;&lt;endl;&#125;class Derived:public Base2&#123;public: void display()const;&#125;;void Derived::display()const&#123; cout&lt;&lt;"Derivd::display()"&lt;&lt;endl;&#125;void fun(Base1 *ptr)&#123; ptr-&gt;display();&#125;int main()&#123; Base2 base2; Derived derived; fun(&amp;base2); fun(&amp;derived); return 0;&#125; 运行结果 123Base2::display()Derivd::display()Program ended with exit code: 0 详情请看 https://blog.csdn.net/wang13342322203/article/details/80512330]]></content>
  </entry>
  <entry>
    <title><![CDATA[浅谈Python多进程与多线程]]></title>
    <url>%2F2019%2F08%2F12%2F%E6%B5%85%E8%B0%88Python%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[浅谈Python多进程与多线程@[toc] 什么是进程，什么是线程进程进程是程序的一次动态执行过程，它对应了从代码加载、执行到执行完毕的一个完整过程。进程是资源分配的最小单位，进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵一个进程若不存在多线程则相当于线程 线程线程是程序执行的最小单位，每个线程中可以实现资源的共享、通信等操作， 但线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。 两者的区别 进程 线程 相同点 两者都是实现多个任务同时运行的方式 不同点 进程拥有独立的资源，进程间相互独立，互不打扰，但线程之间更容易实现共享，同时多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。 多进程在Unix与Linux中系统支持fork()，但在我们常见的系统中不容许Windows可以使用，但Mac OS X与Linux可以使用,但Python是一门可以跨平台的编程语言，对任意系统都支持multiprocessing 其中：os.getpid() 获取当前进程的PID号os.getppid() 获取当前进程父进程的PID号 代码实现Mac OS X下使用fork（）创建子进程fork()语法： 功能：为当前进程创建一个子进程 参数：无 返回值：0 和 子进程PID（在父进程中） &lt; 0 子进程创建失败 = 0 在子进程中的返回值 &gt; 0 在父进程中的返回值 fork()很特殊，它是一个调用一次，返回两次的函数子进程永远返回0，而父进程返回子进程的ID,所以一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用getppid()就可以拿到父进程的ID。 12345678910111213# -*- coding:utf-8 -*-#！usr/bin/env pythonimport os# fork()属于系统内建函数，需从OS模块引入print 'process (%s) strat...' %os.getpid()pid = os.fork()# 调用一次，返回两次if pid == 0:# 判断是否为子进程 print "I'm child process (%s) and my parent is %s" %(os.getpid(),os.getppid())else: print "I (%s) just created a child process (%s)." %(os.getpid(),pid) 输出 123process (58196) strat...I (58196) just created a child process (58198).I&apos;m child process (58198) and my parent is 58196 使用multiprocessing由于windows不可以使用fork（），但python为所有操作系统准备了multiprocess供它们创建子线程 创建子进程时，只需要传入一个执行函数和函数的参数，创建一个Process实例，用start()方法启动，这样创建进程比fork()还要简单。join()方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。 1234567891011121314151617181920212223# -*- coding:utf-8 -*-#！usr/bin/env pythonfrom multiprocessing import Process# 从multiprocessing模块引入Processimport osdef fun(name): print 'Run child process %s(%s)...'%(name,os.getpid()) # 打印当前进程if __name__=='__main__': # 若在本模块运行时 print 'Parent process %s.'%os.getpid() # 打印父进程 p = Process(target=fun,args=('test',)) # 创建一个子进程 print 'Process will start.' p.start() # 开始运行子进程 p.join() # 停止运行子进程 print 'Process end' 输出 1234Parent process 61028.Process will start.Run child process test(61029)...Process end 进程池如果要启动大量的子进程，可以用进程池的方式批量创建子进程： 关键字为poll，Pool的默认大小是CPU的核数；但它也可以设置参数如果为pool（5）则是申请有5个子进程的进程池注意：对Pool对象调用join()方法会等待所有子进程执行完毕，调用join()之前必须先调用close()，调用close()之后就不能继续添加新的Process了。 12345678910111213141516171819202122232425# -*- coding:utf-8 -*-#！usr/bin/env pythonfrom multiprocessing import Pool# 从multiprocess模块引入Poolimport os,time,randomdef long_time_task(name): print 'Run task%s(%s)' % (name, os.getpid()) start = time.time() time.sleep(random.random()*3) # random.random（）产生一个0～1的随机数 end = time.time() print 'Task %s runs %0.2f seconds' % (name, (end-start)) # 输出任务名与运行时间差 if __name__ == '__main__': print 'Parent process %s.' % os.getpid() p = Pool() # 生成一个进程池 for i in range(5): p.apply_async(long_time_task, args=(i,)) print 'Waiting for all subprocesses done...' p.close() p.join() print 'All subprocess done' 输出 1234567891011121314Parent process 66221.Waiting for all subprocesses done...Run task0(66223)Run task1(66224)Run task2(66225)Run task3(66226)Task 1 runs 0.69 secondsRun task4(66224)Task 4 runs 0.91 secondsTask 2 runs 1.97 secondsTask 3 runs 2.19 secondsTask 0 runs 3.00 secondsAll subprocess done3.03261709213 因为我使用的是4核处理器，所以task 4要等待前面某个task完成后才执行 多进程的通信multiprocessing.Queue()Queue是多进程安全的队列，可以使用Queue实现多进程之间的数据传递。put方法用以插入数据到队列中，put方法还有两个可选参数：blocked和timeout。如果blocked为True（默认值），并且timeout为正值，该方法会阻塞timeout指定的时间，直到该队列有剩余的空间。如果超时，会抛出Queue.Full异常。如果blocked为False，但该Queue已满，会立即抛出Queue.Full异常。 get方法可以从队列读取并且删除一个元素。同样，get方法有两个可选参数：blocked和timeout。如果blocked为True（默认值），并且timeout为正值，那么在等待时间内没有取到任何元素，会抛出Queue.Empty异常。如果blocked为False，有两种情况存在，如果Queue有一个值可用，则立即返回该值，否则，如果队列为空，则立即抛出Queue.Empty异常 以Queue为例，在父进程中创建两个子进程，一个往Queue里写数据，一个从Queue里读数据： ==multiprcessing.Queue.put() 为 入队操作== ==multiprcessing.Queue.get() 为 出队操作== 1234567891011121314151617181920212223242526# -*- coding:utf-8 -*-#！usr/bin/env pythonimport multiprocessingdef writer_proc(q): try: q.put(1, block = False) except: pass def reader_proc(q): try: print q.get(block = False) except: passif __name__ == "__main__": q = multiprocessing.Queue() writer = multiprocessing.Process(target=writer_proc, args=(q,)) writer.start() reader = multiprocessing.Process(target=reader_proc, args=(q,)) reader.start() reader.join() writer.join() multiprocessing.Pipe()Pipe方法返回(conn1, conn2)代表一个管道的两个端。Pipe方法有duplex参数，如果duplex参数为True(默认值)，那么这个管道是全双工模式，也就是说conn1和conn2均可收发。duplex为False，conn1只负责接受消息，conn2只负责发送消息。 send和recv方法分别是发送和接受消息的方法。例如，在全双工模式下，可以调用conn1.send发送消息，conn1.recv接收消息。如果没有消息可接收，recv方法会一直阻塞。如果管道已经被关闭，那么recv方法会抛出EOFError。 1234567891011121314151617181920212223242526272829303132# -*- coding:utf-8 -*-#！usr/bin/env pythonimport multiprocessingimport timedef proc1(pipe): while True: for i in range(10): print "send: %s" %(i) pipe.send(i) # 向pipe中发送i值 time.sleep(1)def proc2(pipe): while True: print "proc2 rev:", pipe.recv() # 接受i值 time.sleep(1)if __name__ == "__main__": pipe = multiprocessing.Pipe() # 申请一个pipe p1 = multiprocessing.Process(target=proc1, args=(pipe[0],)) p2 = multiprocessing.Process(target=proc2, args=(pipe[1],)) # 生成两个子进程p1，p2 p1.start() p2.start() # 开始执行进程 p1.join() p2.join() # 结束进程 多线程Python的标准库提供了两个模块：thread和threading，thread是低级模块，threading是高级模块，对thread进行了封装。绝大多数情况下，我们只需要使用threading这个高级模块。 代码实现 单线程 1234567891011121314151617#-*- coding:utf-8 -*-#！usr/bin/env pythonimport timedef fun1(): for i in range(3): print '我在看书',time.ctime() time.sleep(1)def fun2(): for i in range(3): print "我在听歌",time.ctime() time.sleep(1)fun1()fun2() 输出 123456我在看书 Fri Aug 9 22:34:41 2019我在看书 Fri Aug 9 22:34:42 2019我在看书 Fri Aug 9 22:34:43 2019我在听歌 Fri Aug 9 22:34:44 2019我在听歌 Fri Aug 9 22:34:45 2019我在听歌 Fri Aug 9 22:34:46 2019 多线程输出 1234567891011121314151617181920212223242526#-*- coding:utf-8 -*-#！usr/bin/env pythonimport timeimport threadingdef fun1(): for i in range(3): print '我在看书',time.ctime() time.sleep(1)def fun2(): for i in range(3): print "我在听歌",time.ctime() time.sleep(1)p1 = threading.Thread(target=fun1)# 创建一个线程p1p2 = threading.Thread(target=fun2)# 创建一个线程p2p1.start()p2.start()# 执行线程p1.join()p2.join()# 结束线程 123456我在看书 Fri Aug 9 22:37:44 2019我在听歌 Fri Aug 9 22:37:44 2019我在看书 Fri Aug 9 22:37:45 2019我在听歌 Fri Aug 9 22:37:45 2019我在听歌 Fri Aug 9 22:37:46 2019我在看书 Fri Aug 9 22:37:46 2019 线程通信由于线程通信造成的混乱多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了 1234567891011121314151617181920#-*- coding:utf-8 -*-#！usr/bin/env pythonimport timeimport threadingcount = 5def fun(n): global count for i in range(5): count += n time.sleep(1) count -= n print countp1 = threading.Thread(target=fun,args=(5,))p2 = threading.Thread(target=fun,args=(3,))p1.start()p2.start() 输出 123456789105 810810858105 解决方案在Python中提供了关键字lock来防止由于线程通信造成的混乱。由于锁（lock）只有一个，无论多少线程，同一时刻最多只有一个线程持有该锁，所以，不会造成修改的冲突。所以获得lock的线程将会优先执行。所以lock会使各个线程依次执行。但使用lock时，threading.Lock()，要注意获取和释放锁， lock.acquire()、 lock.release() 示例代码： 1234567891011121314151617181920212223242526272829303132#-*- coding:utf-8 -*-#！usr/bin/env pythonimport threadingdef fun1(): global A, lock lock.acquire() for i in range(10): A += 1 print "Thread-1", A lock.release()def fun2(): global A, lock lock.acquire() for i in range(10): A += 10 print "Thread-2", A lock.release()if __name__ == '__main__': lock = threading.Lock() A = 0 t1 = threading.Thread(target=fun1) t2 = threading.Thread(target=fun2) t1.start() t2.start() t1.join() t2.join() 输出 1234567891011121314151617181920Thread-1 1Thread-1 2Thread-1 3Thread-1 4Thread-1 5Thread-1 6Thread-1 7Thread-1 8Thread-1 9Thread-1 10Thread-2 20Thread-2 30Thread-2 40Thread-2 50Thread-2 60Thread-2 70Thread-2 80Thread-2 90Thread-2 100Thread-2 110]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F08%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
