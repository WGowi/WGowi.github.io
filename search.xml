<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[吴恩达机器学习第一章]]></title>
    <url>%2F2020%2F02%2F04%2F%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[吴恩达机器学习第一章[toc] Machine Learning机器学习所研究的主要内容，是关于计算机上从数据中产生“模型”（model）的算法，即“学习算法”（learning algorithm），有了学习算法，我们把经验数据提供给它，它就能基于这些数据产生模型；面对新的情况时，模型会给我们提供相应的判断。其中从数据中学得模型的过程称为称为“训练”（training）或“学习”（learning） 123graph LR机器学习--有标记信息--&gt;监督学习机器学习--无标记信息--&gt;无监督学习 机器学习的目标是使学得的模型能很好的适应于“新样本”，而不是在新样本上工作的好好的，学得的模型适用于新样本的能力，称为“泛化”能力。 Supervised Learning定义：根据已有的数据集，知道输入和输出结果之间的关系。根据这种已知的关系，训练得到一个最优的模型。也就是说，在监督学习中训练数据==既有特征(feature)又有标签(label)==，通过训练，让机器可以自己找到特征和标签之间的联系，在面对只有特征没有标签的数据时，可以判断出标签。 监督学习的分类：回归(Regression）、分类（Classification) 回归问题：针对连续型问题 回归通俗一点就是，对已经存在的点（训练数据）进行分析，拟合出适当的函数模型y=f(x)，这里y就是数据的标签，而对于一个新的自变量x，通过这个函数模型得到标签y。 分类问题：针对离散型问题 Unsupervised Learning定义：我们不知道数据集中数据、特征之间的关系，而是要根据聚类或一定的模型得到数据之间的关系。 可以这么说，比起监督学习，无监督学习更像是自学，让机器学会自己做事情，是没有标签（label）的。我们只是给定了一组数据，我们的目标是发现这组数据中的特殊结构。例如我们使用无监督学习算法会将这组数据分成两个不同的簇,，这样的算法就叫聚类算法。 Answer : B、C]]></content>
  </entry>
  <entry>
    <title><![CDATA[NAO机器人的小记]]></title>
    <url>%2F2019%2F11%2F10%2FNAO%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E5%B0%8F%E8%AE%B0-1%2F</url>
    <content type="text"><![CDATA[NAO机器人的小记@[toc] joint 摄像机相关参数 APIALAutonomousLife孤立状态solitary任何活动都可以通过ALAutonomousLifeProxy :: switchFocus（）启动。启动交互式Activity将切换到交互状态。在保障和禁用状态可以进入。无法停止自动启动板，其建议的活动将自动聚焦，可能会中断正在运行的活动。 交互状态interactive可以通过ALAutonomousLifeProxy :: switchFocus（）启动交互式活动聚焦新的交互式Activity将重新进入交互状态。孤立活动可能无法启动，这将导致孤立状态强制执行其规则并与用户创建不良生命周期。（这可能在未来发生变化）在保障和禁用状态可入以被输。自动启动板可以启动，它不会强制关注其建议。它不会中断正在运行的Activity。当整个交互活动堆栈退出时，将进入单独状态。当所有人都失去时，互动活动将被强行退出。（这尚未实施） 禁用状态disabled没有Activity可以通过ALAutonomousLifeProxy :: switchFocus（）启动无法启动自动启动板。该保障或交互状态可能无法进入。（可调用ALAutonomousLifeProxy :: setState（）退出此状态） 保护状态safeguard没有Activity可以通过ALAutonomousLifeProxy :: switchFocus（）启动 停止聚焦活动并清除堆栈。基本意识和呼吸服务如果正在运行则会停止。自动启动板已停止。然后处理反射。根据反射的结果，可以重新进入孤立状态。（对于损坏的硬件，机器人不会退出保护状态。对于过热，机器人在充分冷却后退出保护状态。） ALRobotPostureALRobotPostureProxy :: getPostureList std :: vector ALRobotPostureProxy :: getPostureList （） 返回：所有预定义姿势的矢量（名称） ALRobotPostureProxy :: getPosture std :: string ALRobotPostureProxy :: getPosture （） 返回当前预定义姿势的名称。如果当前姿势不在预定义姿势中，则返回“未知”。 ALRobotPostureProxy :: goToPosture bool ALRobotPostureProxy :: goToPosture （const std :: string postureName，const float speed ） 使机器人进入参数中要求的预定义姿势。可以修改移动的速度。移动是“智能的”：它将从机器人的开始姿势开始，并选择所有步骤以达到要求的姿势。这是一个阻塞调用。 ALMotionALMotionProxy :: setStiffnesses void ALMotionProxy :: setStiffnesses （const AL :: ALValue＆ names，const AL :: ALValue＆ stiffnesses ）设置一个或多个关节的刚度。这是一个非阻塞调用。names - 关节，链条，“主体”，“JointActuators”，“接头”或“执行器”的名称。stiffnesses - 零和一之间的一个或多个刚度。 示例：＃显示如何将刚度设置为1.0 。 ＃注意，这样做可能很危险，使用 ＃stiffnessInterpolation方法更安全，该方法需要持续时间参数。 names =’Body’ ＃如果只接收到一个参数，这将应用于所有关节 stiffnesses = 1.0 motionProxy.setStiffnesses(names, stiffnesses) ALMotionProxy :: getStiffnesses std::vectorALMotionProxy::getStiffnesses(const AL::ALValue&amp; jointName)获取关节或关节组的刚度jointName - 关节，链，“Body”，“JointActuators”，“Joints”或“Actuators”的名称。返回：一个或多个刚度。1.0表示最大刚度。0.0表示最小刚度 ALMotionProxy :: angleInterpolation void ALMotionProxy :: angleInterpolation （const AL :: ALValue＆ names，const AL :: ALValue＆ angleLists，const AL :: ALValue＆ timeLists，const bool＆isAbsolute ）将一个或多个关节插值到目标角度或沿着定时轨迹。这是一个阻塞调用。names– 关节，链条，“主体”，“JointActuators”，“接头”或“执行器”的名称或名称。angleLists - 以弧度表示的角度，角度列表或角度列表列表timeLists - 时间，时间列表或时间列表列表，以秒为单位isAbsolute - 如果为true，则以绝对角度描述运动，否则角度相对于当前角度。 示例：＃显示一个关节的单个目标角度的示例 ＃在1.0秒内将头部偏航插入1.0弧度 names =“HeadYaw” angleLists = 50.0 * almath.TO_RAD timeLists = 1.0 isAbsolute = True motionProxy.angleInterpolation（names，angleLists，timeLists，isAbsolute） ＃显示一个关节的单个轨迹的示例 ＃将头部偏航插入1.0弧度，并在2.0秒内回零 names =“HeadYaw” ＃2角度 angleLists = [30.0 * almath.TO_RAD，0.0] ＃ 2次 timeLists = [1.0,2.0] #后面的时间一定要比原来的大（timeLists = [1.0,1.0] 报错：times must be increasing 所以应该表示的是总的时间 在1s内转30度 在2s内转30度再转回来 即转回的时间也是1s） isAbsolute = True motionProxy.angleInterpolation（names，angleLists，timeLists，isAbsolute） ＃显示多个轨迹的示例 names = [“HeadYaw”，“HeadPitch”] angleLists = [30.0 * almath.TO_RAD，30.0 * almath.TO_RAD] #左下方 timeLists = [1.0,1.2] #（可以为timeLists = [1.0,1.0]） isAbsolute = True motionProxy.angleInterpolation（names，angleLists，timeLists，isAbsolute） ＃显示多个轨迹的示例 ＃将头部偏航插入1.0弧度，并在2.0秒内回零 ＃在长时间内上下插入HeadPitch。 names = [“HeadYaw”，“HeadPitch”] ＃每个关节可以有不同长度的列表，但数量 ＃角度和每个关节的次数必须相同。 ＃这里，第二个关节（“HeadPitch”）有三个角度，和 ＃三个相应的时间。 angleLists = [[50.0 * almath.TO_RAD，0.0]， [-30.0 * almath.TO_RAD，30.0 * almath.TO_RAD，0.0]] timeLists = [[1.0,2.0]，[1.0,2.0,3.0]] isAbsolute = True motionProxy.angleInterpolation（names，angleLists，timeLists，isAbsolute） ALMotionProxy :: angleInterpolationWithSpeed void ALMotionProxy :: angleInterpolationWithSpeed （const AL :: ALValue＆ names，const AL :: ALValue＆targetAngles，const float＆maxSpeedFraction ）使用最大速度的一小部分将一个或多个关节插值到目标角度。每个关节只允许一个目标角度。这是一个阻塞调用。names - 关节，链条，“主体”，“JointActuators”，“接头”或“执行器”的名称或名称。targetAngles - 以弧度表示的角度或角度列表maxSpeedFraction - 一个分数 示例：＃显示一个关节的单个目标的示例 names =“HeadYaw” targetAngles = 1.0 maxSpeedFraction = 0.2＃使用最大关节速度的20％ motionProxy.angleInterpolationWithSpeed（names，targetAngles，maxSpeedFraction） ＃显示多个关节的示例 ＃而不是列出每个关节，您可以使用链名称 #bein扩展为包含链中的所有关节。在这种情况下， ＃“Head”将被解释为[“HeadYaw”，“HeadPitch”] names =“Head” ＃我们仍然需要指定正确的目标角度数 targetAngles = [0.5,0.25] maxSpeedFraction = 0.2＃使用最大关节速度的20％ motionProxy.angleInterpolationWithSpeed（names，targetAngles，maxSpeedFraction） ＃显示体零位置的示例 ＃而不是列出每个关节，您可以使用名称“Body” names =’Body’ ＃我们仍然需要指定正确的目标角度数，所以 ＃我们需要找到这个Nao的关节数量。 ＃这里我们使用getBodyNames方法，它告诉我们所有人 ＃别名“Body”中关节的名称。 ＃我们可以将此列表用于“names”参数。 numJoints = len(motionProxy.getBodyNames(“Body”)) ＃列出正确的长度。所有角度都为零。 targetAngles = [0.0] * numJoints ＃使用最大关节速度的10％ maxSpeedFraction = 0.1 motionProxy.angleInterpolationWithSpeed(names, targetAngles, maxSpeedFraction) ALMotionProxy :: move void ALMotionProxy :: move （const float＆ x，const float＆ y，const float＆theta，const AL :: ALValue moveConfig ）1方法的重载使机器人以给定的速度移动，以FRAME_ROBOT表示，具有移动配置。这是一个非阻塞调用。x - 沿X轴的速度，以米/秒为单位。向后运动使用负值y - 沿Y轴的速度，以米/秒为单位。使用正值向左移动theta - 绕Z轴的速度，以弧度/秒为单位。使用负值顺时针旋转moveConfig - 具有自定义移动配置的ALValue。 ALMotionProxy :: moveTowardvoid ALMotionProxy :: moveToward （const float＆ x，const float＆ y，const float＆theta，const AL :: ALValue moveConfig ）使机器人以给定的标准化速度移动，以FRAME_ROBOT表示，具有移动配置。这是一个非阻塞调用。 x - 沿X轴标准化，无单位，速度。+1和-1分别对应于前向和后向的最大速度。y - 沿Y轴标准化，无单位，速度。+1和-1分别对应于左右方向上的最大速度。theta-标准化，无单位，绕Z轴的速度。+1和-1分别对应于逆时针和顺时针方向的最大速度moveConfig - 具有自定义移动配置的ALValue。 ＃示例显示moveToward的使用 ＃参数是最大值的分数 ＃这里我们要求全速前进 x = 1.0 y = 0.0 theta = 0.0 frequency = 1.0 motionProxy.moveToward(x, y, theta, [[“Frequency”, frequency]])＃如果我们不发送另一个命令，他将永远移动 ＃让我们让他慢下来（步长），并打开后3秒time.sleep(3) x = 0.5 theta = 0.6motionProxy.moveToward(x, y, theta, [[“Frequency”, frequency]]) ALMotionProxy :: setFootStepsWithSpeed void ALMotionProxy :: setFootStepsWithSpeed （const std :: vector ＆ legName，const AL :: ALValue＆ footSteps，const std :: vector ＆ fractionMaxSpeed，const bool＆ clearExisting ）仅限NAO使机器人快速地做足步计划器。这是一个阻塞调用。legName - 要移动的腿的名称（’LLeg’or’RLeg’）footSteps - [x，y，theta]，[沿X / Y的位置，Z轴的方向]，相对于另一个腿，以[米，米，弧度]为单位。必须小于[MaxStepX，MaxStepY，MaxStepTheta]fractionMaxSpeed - 每步脚的速度。必须介于0和1之间clearExisting - 清除现有的脚步 ＃小步前进和逆时针用左脚 legName = [“LLeg”] X = 0.04 Y = 0.1 Theta = 0.3 footSteps = [[X, Y, Theta]] fractionMaxSpeed = [1.0] clearExisting = False motionProxy.setFootStepsWithSpeed(legName, footSteps, fractionMaxSpeed, clearExisting) ＃小步前进和逆时针用左脚 legName = [“LLeg”, “RLeg”] X = 0.04 Y = 0.1 Theta = 0.3 footSteps = [[X, Y, Theta], [X, -Y, Theta]] fractionMaxSpeed = [1.0, 1.0] clearExisting = FalsemotionProxy.setFootStepsWithSpeed(legName, footSteps, fractionMaxSpeed, clearExisting) ALMotionProxy :: waitUntilMoveIsFinished void ALMotionProxy :: waitUntilMoveIsFinished （） 等待MoveTask结束：此方法可用于阻止脚本/代码执行，直到完成移动任务。 ALMemoryALMemoryProxy :: getData ALMemoryProxy :: getDataList ALMemoryProxy :: declareEvent ALMemoryProxy :: insertData ALTrackerALTrackerProxy :: getActiveTarget ALTrackerProxy :: getMaximumDistanceDetection ALTrackerProxy::getMode ALTrackerProxy :: getRelativePosition ALTrackerProxy :: isNewTargetDetected ALTrackerProxy::isSearchEnabled ALTrackerProxy :: getTargetPosition ALTrackerProxy::isTargetLost ALTrackerProxy::setTimeOut EventsALLandMarkDetection 结果变量的组织方式 ①如果未检测到Naomarks，则变量为空。更确切地说，它是一个零元素的数组（即在python中打印为[]） ②如果检测到N个Naomarks，则变量结构由两个字段组成：[[TimeStampField] [Mark_info_0，Mark_info_1 ,. 。。，Mark_info_N-1]]：A：TimeStampField = [TimeStamp_seconds，Timestamp_microseconds]。该字段是用于执行检测的图像的时间戳。B：Mark_info = [ShapeInfo，ExtraInfo]。对于每个检测到的标记，我们有一个Mark_info字段。B\1 ShapeInfo = [1，alpha，beta，sizeX，sizeY，heading]。alpha和beta表示Naomark在摄像机角度方面的位置 - sizeX和sizeY是摄像机角度的标记大小 - 航向角描述了Naomark关于机器人头部的垂直轴方向。B\2 ExtraInfo = [MarkID]。标记ID是写在Naomark上的编号，与其图案相对应。 ALRedBallDetection ALRedBallDetection基于摄像机给出的图像中红色像素的检测。这些像素根据它们与YUV颜色空间中的红色值的距离进行滤波，使用计算的阈值，即使在光照条件变化的情况下也可以进行检测。然后，从所有检测到的红色像素组中，仅保留定义圆形形状的红色像素。当在当前图像上找到一组像素时，将更新ALMemory键redBallDetected。 结果变量的组织形式 TimeStamp：此字段是用于执行检测的图像的时间戳 centerX和centerY是球的中心角度坐标（弧度）角度的原点是图像的中间。centerX 对应于沿Z轴的直接（逆时针）旋转，centerY对应于沿Y轴的直接旋转，如下图所示： sizeX和sizeY是球在角度（弧度）的球“水平和垂直半径 相关名词参考系 FRAME_TORSO：这是附加到机器人的躯干参考上的，因此机器人在走路时随其移动，在他倾斜时改变方向。当您执行非常局部的任务时（在躯干框架的方向上有意义），此空间很有用。 FRAME_ROBOT：这是围绕垂直Z轴投影的两只脚位置的平均值。该空间很有用，因为x轴始终向前，因此提供了一个以自我为中心的自然参考。 FRAME_WORLD：这是一个固定的原点，永远不会改变。当机器人行走时，它会被留下，并且在机器人转动之后z旋转会有所不同。此空间对于需要外部绝对参考框架的计算很有用。 执行任务时，空间是在任务开始时确定的，并且在其余的插值过程中始终保持不变。也就是说，插值一旦定义就不会随着腿的移动或躯干方向的变化而随着参考值的变化而变化。 刚度 阻塞方法与非阻塞方法 Position6DPosition6D是一个6维向量，由3个平移（以米为单位）和3个旋转（以弧度为单位）组成。 基于NAO机器人目标识别与定位算法 选自：柏雪峰,杨斌.基于NAO机器人目标识别与定位算法[J].成都信息工程学院学报,2014,29(06):625-629.]]></content>
  </entry>
  <entry>
    <title><![CDATA[欧拉角]]></title>
    <url>%2F2019%2F11%2F10%2F%E6%AC%A7%E6%8B%89%E8%A7%92-1%2F</url>
    <content type="text"><![CDATA[欧拉角由于在NAO机器人编程中第一次接触到pitch、yaw以及roll所以写此blog 设定xyz-轴为参考系的参考轴。称xy-平面与XY-平面的相交为交点线，用英文字母（N）代表 $\alpha$ 是x-轴与交点线的夹角，$\beta$ 是z-轴与Z-轴的夹角，$\gamma$是交点线与X-轴的夹角。 $\alpha$ 和$\gamma$值分别从0至$2\pi$ 弧度。$\beta$ 值从0至$2\pi$ 弧度。 下面三张动图形象的表示了欧拉角的旋转方式 pitch是围绕X轴旋转，也叫做俯仰角 yaw是围绕Y轴旋转，也叫偏航角 roll是围绕Z轴旋转，也叫翻滚角]]></content>
  </entry>
  <entry>
    <title><![CDATA[利用单目视觉做NAO机器人摄像头坐标转换]]></title>
    <url>%2F2019%2F11%2F10%2F%E5%88%A9%E7%94%A8%E5%8D%95%E7%9B%AE%E8%A7%86%E8%A7%89%E5%81%9ANAO%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%91%84%E5%83%8F%E5%A4%B4%E5%9D%90%E6%A0%87%E8%BD%AC%E6%8D%A2-1%2F</url>
    <content type="text"><![CDATA[利用单目视觉做NAO机器人摄像头坐标转换趁着比赛将近，总结一下对于NAO机器人摄像头坐标转换问题的理解。 一.问题的来由：为了让NAO机器人识别某个物体，然后走到物体面前一段距离的位置停止，需要知道NAO和物体的距离和角度。通过查找aldebaran documentation可知用函数getTargetPositon（）可以得到某些特定的物体的坐标。 http://doc.aldebaran.com/2-1/naoqi/trackers/altracker.html#tracking-targets 但是对于一般的物体而言这个并没有什么卵用。。 二.解决办法 用简单的单目测距原理和相似三角形原理作一个坐标变换： 设以摄像头为坐标原点的坐标系为A（原点：摄像头镜头，X轴正前方，Y轴左前方） 以摄像头焦平面为坐标原点的坐标系为B（原点：2D图像中心（640x480的图就是（320，240）啦），注意这个X轴和Y轴方向如图所示： 图中的角60.97°和47.64°分别是NAO机器人的水平张角和垂直张角。 由三角函数变换：alpha=((320-x)/640)60.97pi/180 beta=((y-240)/480)47.64pi/180 由NAO提供的API，getAngles（）参数设置成HeadYaw和HeadPitch获得头部姿态，假设是Rotation1和Rotation2，则可以得到校正后的alpha’和beta’: alpha’=alpha+Rotation1 beta’=beta+Rotation2 然后通过AngleInterpolation()将头部转到目标物中间，理想状态下应该物体重心点正好在图像的中心（320,240) 三.接着就可以测量距离啦通过以上变换是为了让机器人的摄像头正好对准物体中心，这样构造出来的计算距离的模型会是一个平面三角形，简化了计算。 V5的NAO身高H总共是459.59mm，假设物体长度L，则有： tan(phi+theta)=(H-L/2)/S 其中theta是下摄像头和水平方向夹角，为39.7° phi可以由函数getangle（）带入参数”HeadPitch”得到 将已知条件代入即可得到距离S 以上是一种简单的获得物体坐标的方式，其优点是写代码简单快捷，缺点是没有摄像头标定精度较低，且应用范围较小。可作为替代的还有双目视觉和采用深度摄像头获得三维坐标的方案，等有空再更新。]]></content>
  </entry>
  <entry>
    <title><![CDATA[python实现ID3 决策树]]></title>
    <url>%2F2019%2F11%2F10%2Fpython%E5%AE%9E%E7%8E%B0ID3-%E5%86%B3%E7%AD%96%E6%A0%91%2F</url>
    <content type="text"><![CDATA[python实现ID3 决策树素材AllElectronics.csv 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import csvfrom sklearn import treefrom sklearn import preprocessingfrom sklearn.feature_extraction import DictVectorizerallElectronicsData = open(r'AllElectronics.csv', 'r') #reader = csv.reader(allElectronicsData) # 迭代器headers = next(reader)print("reader:"+str(reader))print("headers:"+str(headers))featureList = []labelList = []for row in reader: print(row) labelList.append((row[len(row) - 1])) # 把预测项作为labelList的元素 rowDict = &#123;&#125; for i in range(1, len(row) - 1): # 从1开始是因为要防止读取RID rowDict[headers[i]] = row[i] featureList.append(rowDict)print("labelList:"+str(labelList))print("featureList:"+str(featureList)) # 列表里面含有字典vec = DictVectorizer() # 符号化将字典转换成0、1字符dummyX = vec.fit_transform(featureList).toarray() # 将featureList转化成0、1字符print('dummyX:'+str(dummyX))print("feature_names:"+str(vec.get_feature_names())) # 打印每一个特征值用键值对合并表示print("labelList:"+str(labelList))lb = preprocessing.LabelBinarizer() # 二值化dummyY = lb.fit_transform(labelList) # 将labelList中相反的值转化成0，1字符print("dummyY:"+str(dummyY))clf = tree.DecisionTreeClassifier(criterion='entropy') # 按信息熵来使用决策树ID3算法clf = clf.fit(dummyX, dummyY) # 按dummyX，dummyY拟合print("clf:"+str(dummyY))with open("allElectronicInformationGainOri.dot", 'w') as f: f = tree.export_graphviz(clf, feature_names=vec.get_feature_names(), out_file=f) # 把clf写入并生成allElectronicInformationGainOri.dot文件oneRowX = dummyX[0, :] # 获取训练集的第一行数据print("oneRowX:", str(oneRowX))newRowX = oneRowXnewRowX[0] = 1newRowX[2] = 0# 修改newRowX的并作为测试集print("newRowX:" + str(newRowX))predictedY = clf.predict([newRowX]) # 测试print("predictedY:" + str(predictedY)) 输出]]></content>
  </entry>
  <entry>
    <title><![CDATA[数字图像处理关于傅里叶变换的小记]]></title>
    <url>%2F2019%2F11%2F10%2F%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%85%B3%E4%BA%8E%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E7%9A%84%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[数字图像处理关于傅里叶变换的小记@[toc] 背景傅里叶级数得名于法国数学家约瑟夫·傅里叶(1768年–1830年)，他提出==任何周期函数都可以展开为三角级数==。此前数学家如拉格朗日等已经找到了一些非周期函数的三角级数展开，而认定一个函数有三角级数展开之后，通过积分方法计算其系数的公式，欧拉、达朗贝尔和克莱罗早已发现，傅里叶的工作得到了丹尼尔·伯努利的赞助。傅里叶介入三角级数用来解热传导方程，其最初论文在1807年经拉格朗日、拉普拉斯和勒让德评审后被拒绝出版，他的现在被称为傅里叶逆转定理的理论后来发表于1820年的《热的解析理论》中。将周期函数分解为简单振荡函数的总和的最早想法，可以追溯至公元前3世纪古代天文学家的均轮和本轮学说。 傅里叶级数在数论、组合数学、信号处理、概率论、统计学、密码学、声学、光学等领域都有着广泛的应用。 傅里叶在这个领域的贡献是，他指出任何周期函数都可以表示为不同频率的正弦和/或余弦函数之后的形式，每一个正弦项和/或余弦都乘以不同的系数，无论函数多么复杂，只要它是周期性的，并且满足一些适度的数学条件，都可以用这样的和来表示。即任何周期函数，都可以看作是不同振幅，不同相位正弦波的叠加。甚至非周期函数（但该曲线的面积是有限的情况下）也可用正弦和/或余弦乘以加权函数的积分来表示。 傅里叶变换原来就是一种变换而已，只是这种变换是从时间转换为频率的变化 参考链接 https://zh.wikipedia.org/wiki/%E5%82%85%E9%87%8C%E5%8F%B6%E7%BA%A7%E6%95%B0https://www.cnblogs.com/h2zZhou/articles/8405717.html 复数$|Z|=\sqrt{x^2+y^2}$Z =｜Z｜(cosθ+jsinθ)e^jθ^=cosθ+jsinθ则可得：θ 12import mathprint(math.acos(1/math.sqrt(5))) 输出 11.1071487177940904 傅里叶级数频域与时域 [video(video-W1GLGCWF-1571408450268)(type-tencent)(url-https://v.qq.com/txp/iframe/player.html?vid=r0543lhhz4a)(title-傅立叶变换，傅里叶级数和频谱)] 复数形式的傅里叶级数的证明 傅立叶变换与傅立叶逆变换一维离散傅立叶变换 12345678910111213141516171819# 单变量的离散傅立叶变换 P138import numpy as npdef DFT(x): M = np.size(x) new_x = np.zeros((M, ), dtype=np.complex) for n in range(0, M): for m in range(0, M): new_x[n] += x[m]*np.exp(-2j*np.pi*m*n/M) return new_xx = np.random.rand(1024, )x1 = DFT(x)x2 = np.fft.fft(x)print("x1", x1)print("x2", x2)print('Is DFT close to fft?', np.allclose(x1, x2, 1e-12)) 二维离散傅立叶变换1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# 二维离散傅立叶变换import numpyimport cv2 as cvimport timedef FFT_v1(Img, Wr): if Img.shape[0] == 2: pic = numpy.zeros([2], dtype=complex) pic = pic * (1 + 0j) pic[0] = Img[0] + Img[1] * Wr[0] pic[1] = Img[0] - Img[1] * Wr[0] return pic else: pic = numpy.empty([Img.shape[0]], dtype=complex) pic[0:Img.shape[0] // 2] = FFT_v1(Img[::2], Wr[::2]) + Wr * FFT_v1(Img[1::2], Wr[::2]) pic[Img.shape[0] // 2:Img.shape[0]] = FFT_v1(Img[::2], Wr[::2]) - Wr * FFT_v1(Img[1::2], Wr[::2]) return picdef FFT_1d(Img): Wr = numpy.ones([Img.shape[0] // 2]) * [ numpy.cos(2 * numpy.pi * i / Img.shape[0]) - 1j * numpy.sin(2 * numpy.pi * i / Img.shape[0]) for i in numpy.arange(Img.shape[0] / 2)] return FFT_v1(Img, Wr)def FFT_2d(Img): pic = numpy.zeros([Img.shape[0], Img.shape[1]], dtype=complex) for i in numpy.arange(Img.shape[0]): pic[:, i] = FFT_1d(Img[:, i]) for i in numpy.arange(Img.shape[1]): pic[i, :] = FFT_1d(pic[i, :]) return picif __name__ == "__main__": array = numpy.zeros([512], dtype=complex) img = cv.imread('p1.jpg', 0) print("numpy.fft.fft2()函数计算结果：") t_s1 = time.time() a=numpy.fft.fft2(img) print(a) t_e1 = time.time() print("计算时间：" + str(t_e1 - t_s1)) print("FFT_2d()函数的计算结果：") t_s2 = time.time() b=FFT_2d(img) print(b) t_e2 = time.time() print("计算时间：" + str(t_e2 - t_s2)) print(a == b) print(numpy.allclose(a, b), 1e-12) 时间消耗12345678910111213141516171819202122232425262728293031323334353637383940414243444546import timeimport numpyimport matplotlib.pyplot as pyplotdef DFT(x): N = numpy.size(x) X = numpy.zeros((N,),dtype=numpy.complex128) for m in range(0,N): for n in range(0,N): X[m] += x[n]*numpy.exp(-numpy.pi*2j*m*n/N) return Xdft_time = []fft_time = []n_series = []for N in numpy.power(2,range(1,11)): print(N) x = numpy.ones((N,)) t0 = time.time() for pp in range(0,2): X = DFT(x) print(X) t1 = (time.time()-t0)/2.0 t0 = time.time() for pp in range(0,2): Y = numpy.fft.fft(x) t2 = (time.time()-t0)/2.0 n_series.append(N) dft_time.append(t1) fft_time.append(t2)line_dft, = pyplot.plot(n_series, dft_time, label='DFT')line_fft, = pyplot.plot(n_series, fft_time,'r',label='FFT')pyplot.legend(handles=[line_dft, line_fft])pyplot.ylabel('times(second)')pyplot.xlabel('N')pyplot.show()print(dft_time)print(fft_time)print(numpy.allclose(X, Y), 1e-12)print(X == Y) 1234567891011121314151617181920212223242526272829303132333435import cv2 as cvimport numpy as npimport matplotlib.pyplot as pltimport timeimg = cv.imread('t1.png', 0)plt.subplot(131)plt.title("original")plt.axis('off')plt.imshow(img, cmap='gray')f = np.fft.fft2(img) # 快速傅里叶变换算法得到频率分布fshift = np.fft.fftshift(f) # 默认结果中心点位置是在左上角,调用fftshift()函数转移到中间位置fimg = np.log(np.abs(fshift)) # fft结果是复数, 其绝对值结果是振幅，频谱对数变换,取对数放大波动#展示结果plt.subplot(132)plt.title('Fourier Fourier')plt.axis('off')plt.imshow(fimg, 'gray')# 傅立叶逆变换plt.subplot(133)ifshift = np.fft.ifftshift(fshift)iimg = np.fft.ifft2(ifshift)iimg = np.abs(iimg)plt.axis('off')plt.title('Inverse Fourier Image')plt.imshow(iimg, 'gray')plt.savefig('test0.png')plt.show() 左边为原始图像，中间为频率分布图谱，其中越靠近中心位置频率越低，越亮（灰度值越高）的位置代表该频率的信号振幅越大，右边为傅立叶逆变换得到的图像。 #计算一维傅里叶变换numpy.fft.fft(a, n=None, axis=-1, norm=None) #计算二维的傅里叶变换numpy.fft.fft2(a, n=None, axis=-1, norm=None) #计算n维的傅里叶变换numpy.fft.fftn() #计算n维实数的傅里叶变换numpy.fft.rfftn() #返回傅里叶变换的采样频率numpy.fft.fftfreq() #将FFT输出中的直流分量移动到频谱中央numpy.fft.shift() #实现图像逆傅里叶变换，返回一个复数数组numpy.fft.ifft2(a, n=None, axis=-1, norm=None) #fftshit()函数的逆函数，它将频谱图像的中心低频部分移动至左上角numpy.fft.fftshift() #将复数转换为0至255范围iimg = numpy.abs(逆傅里叶变换结果) 冲激 以一个面积为1的三角形为例，底边不断收缩，当底边a-&gt;0时，高-&gt;∞ 卷积 卷积的求法（利用傅立叶变换）卷积与傅里叶变换有着密切的关系。例如两函数的傅里叶变换的乘积等于它们卷积后的傅里叶变换，利用此一性质，能简化傅里叶分析中的许多问题。 Nyquist采样定理象一个白色的圆盘，有一条沿着半径的黑线，圆盘以角速度[公式]旋转。你以一定的周期拍照，就是采样。你拍照的频率恰好为圆盘自转频率两倍的时候，你的照片里黑线的位置，永远是下一张和上一张呈180度，看不出圆盘原来到底是顺时针转的还是逆时针转的。 图像的内插和重采样1234567891011121314151617181920212223242526272829303132# 最近邻内插算法import cv2 as cvimport numpy as npimg = cv.imread("Fig0417(a)(barbara).tif", 0)height, width = img.shapefx = 0.5fy = 0.5new_height = int(fx*height)new_width = int(fy*width)new_img = np.zeros((new_height, new_width), dtype=np.uint8)for i in range(height): for j in range(width): new_i = int(fx*i) new_j = int(fy*j) new_img[new_i, new_j] = img[i, j]new_img1 = cv.resize(img, (0, 0), fx=0.5, fy=0.5, interpolation=cv.INTER_NEAREST)new_img2 = cv.resize(new_img1, (0, 0), fx=2, fy=2, interpolation=cv.INTER_NEAREST)new_img3 = cv.resize(new_img, (0, 0), fx=2, fy=2, interpolation=cv.INTER_NEAREST)while 1: cv.imshow("img", img) cv.imshow('new_img', new_img) cv.imshow('new_img1', new_img1) cv.imshow('new_img2', new_img2) cv.imshow('new_img3', new_img3) if cv.waitKey(1) == 27: break 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# 双线性内插法import cv2 as cvimport numpy as npimport timedef resize(src, fx, fy): src_h, src_w = src.shape[:2] dst_w, dst_h = int(src_w*fx), int(src_h*fy) if fx == 1 and fy == 1: return src.copy() # 遍历目标图像，插值 dst = np.zeros((dst_h, dst_w, 3), dtype=np.uint8) for n in range(3): # 对channel循环 for dst_y in range(dst_h): # 对height循环 for dst_x in range(dst_w): # 对width循环 # 目标在源上的坐标 src_x = (dst_x + 0.5) / fx - 0.5 src_y = (dst_y + 0.5) / fy - 0.5 # 计算在源图上四个近邻点的位置 src_x_0 = int(np.floor(src_x)) src_y_0 = int(np.floor(src_y)) src_x_1 = min(src_x_0 + 1, src_w - 1) src_y_1 = min(src_y_0 + 1, src_h - 1) # 双线性插值 value0 = (src_x_1 - src_x) * src[src_y_0, src_x_0, n] + (src_x - src_x_0) * src[src_y_0, src_x_1, n] value1 = (src_x_1 - src_x) * src[src_y_1, src_x_0, n] + (src_x - src_x_0) * src[src_y_1, src_x_1, n] dst[dst_y, dst_x, n] = int((src_y_1 - src_y) * value0 + (src_y - src_y_0) * value1) return dstif __name__ == '__main__': img = cv.imread('Fig0417(a)(barbara).tif') start = time.time() img_out = resize(img, fx=0.5, fy=0.5) img_out0 = cv.resize(img, (0, 0), fx=0.5, fy=0.5, interpolation=cv.INTER_LINEAR_EXACT) print('cost '+str(time.time() - start)+' seconds') while 1: cv.imshow('src_image', img) cv.imshow('dst_image', img_out) cv.imshow('dst_image0', img_out0) if cv.waitKey(1) == 27: break 参考傅立叶变换，傅立叶序列以及频谱傅立叶级数深入浅出的讲解傅里叶变换（真正的通俗易懂）numpy.fft.fft]]></content>
  </entry>
  <entry>
    <title><![CDATA[图像翻转]]></title>
    <url>%2F2019%2F11%2F10%2F%E5%9B%BE%E5%83%8F%E7%BF%BB%E8%BD%AC-1%2F</url>
    <content type="text"><![CDATA[图像翻转我们可以利用仿射变换来翻转图片仿射变换参考链接: https://blog.csdn.net/qq_43309286/article/details/101595206 输入： 图像翻转90度可以直接利用矩阵转置 123456789101112131415161718192021# 图像翻转90度import cv2 as cvimport numpy as npimport matplotlib.pyplot as pltfrom PIL import Imageimg0 = cv.imread('t3.jpg', 0)img0 = cv.resize(img0, (0, 0), fx=0.2, fy=0.2)height, width = img0.shapeimg_arr = np.array(img0)new_img = np.zeros((height, width), dtype='uint8')new_img = img_arr.Tcv.imshow('new_img', new_img)cv.waitKey(0)cv.destroyAllWindows() 输出： 图片翻转180度12345678910111213141516171819202122# 翻转180度import cv2 as cvimport numpy as npimport matplotlib.pyplot as pltfrom PIL import Imageimg0 = cv.imread('t3.jpg', 0)height, width = img0.shapeimg_arr = np.array(img0)new_img = np.zeros((height, width), dtype='uint8')for i in range(height): for j in range(width): new_img[height-1-i][width-1-j] = img0[i][j]cv.imshow('new_img', new_img)cv.waitKey(0)cv.destroyAllWindows() 输出： 图片倾斜1234567891011121314151617181920212223# 图片倾斜import cv2 as cvimport numpy as npimport matplotlib.pyplot as pltfrom PIL import Imageimg0 = cv.imread('t3.jpg', 0)height, width = img0.shapeimg_arr = np.array(img0)new_img = np.zeros((height+100, width+100), dtype='uint8')for i in range(height): for j in range(width): new_img[int(i*np.cos(np.pi/4)-j*np.sin(np.pi/4))][int(i*np.sin(np.pi/4)+j*np.cos(np.pi/4))] = img0[i][j] # new_img[i][2*i+j] = img0[i][j]while True: cv.imshow('new_img', new_img) if (cv.waitKey(1) == 27): break 输出：]]></content>
  </entry>
  <entry>
    <title><![CDATA[灰度取反]]></title>
    <url>%2F2019%2F11%2F10%2F%E7%81%B0%E5%BA%A6%E5%8F%96%E5%8F%8D-1%2F</url>
    <content type="text"><![CDATA[灰度取反123456789101112131415161718192021# 灰度取反import cv2 as cvimport numpy as npimport matplotlib.pyplot as pltfrom PIL import Imageimg = cv.imread('t1.jpg')height, width, channel = img.shapefor i in range(height): for j in range(width): for k in range(channel): img[i][j][k] = 255-img[i][j][k]while True: cv.imshow('img', img) if(cv.waitKey(0) == 27): breakcv.destroyAllWindows() 输入： 输出：]]></content>
  </entry>
  <entry>
    <title><![CDATA[计算灰度图的均值和方差]]></title>
    <url>%2F2019%2F11%2F10%2F%E8%AE%A1%E7%AE%97%E7%81%B0%E5%BA%A6%E5%9B%BE%E7%9A%84%E5%9D%87%E5%80%BC%E5%92%8C%E6%96%B9%E5%B7%AE-1%2F</url>
    <content type="text"><![CDATA[计算灰度图的均值和方差@[toc] 均值图片的灰度均值是各个像素点的灰度值的平均值 代码实现12345678910111213# 计算灰度均值import cv2 as cvimg = cv.imread('t0.jpg', 0)height, width = img.shapesize = img.sizeaverage = 0for i in range(height): for j in range(width): average += img[i][j]/sizeprint(average) 方差 代码实现123456789101112131415161718192021222324# 计算灰度方差import cv2 as cvimg = cv.imread('t0.jpg', 0)height, width = img.shapesize = img.sizep = [0]*256for i in range(height): for j in range(width): p[img[i][j]] += 1m = 0for i in range(256): p[i] /= 256 m += i*p[i]s = 0for i in range(256): s += (i-m)*(i-m)*p[i]print(s)]]></content>
  </entry>
  <entry>
    <title><![CDATA[数字图像处理——直方图匹配【像素级别处理】（python）]]></title>
    <url>%2F2019%2F11%2F10%2F%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E2%80%94%E2%80%94%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%8C%B9%E9%85%8D%E3%80%90%E5%83%8F%E7%B4%A0%E7%BA%A7%E5%88%AB%E5%A4%84%E7%90%86%E3%80%91%EF%BC%88python%EF%BC%89%2F</url>
    <content type="text"><![CDATA[数字图像处理——直方图匹配【像素级别处理】（python）@[toc] 直方图匹配实现步骤 由输入图像得到pr( r) ，并由$(L-1)\int_{0}^{r}$Pr$( w)dw$求得s的值 使用$G(z)=(L-1)\int_{0}^{r}$Pz$( t)dt$中指定的PDF来求得变换函数$G(z)$ 求得反变换函数$z=G$^-1^$(x)$ ;因为z是由s得到的，所以处理是s到z 的映射，而后者正是我们所期望的值 首先用$(L-1)\int_{0}^{r}$Pr$( w)dw$对输入的图像进行均衡得到输出图像；该图像的像素值是s值，对均衡后的图像中具有s值的每一个像素执行$z=G$^-1^$(x)$，得到输出图像中的相应像素。当所有像素处理完后，输出图像的PDF将等于指定的PDF。 对于反函数的变换就是x与y互换，若存在函数$u=f(x)$、$v=g(x)$,其$g(x)$为$f(x)$的反函数，即$f$^-1^$(x)=g(x)$可表示为$v=g(f(x))$ 代码实现输入： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164import cv2import numpy as npimport matplotlib.pyplot as pltimg = cv2.imread('Fig0323.tif') # 月球表面图片H = img.shape[0]W = img.shape[1]x = np.arange(256) # 作为index使用hr = np.zeros(256) # 原始图片的灰度统计pr = np.zeros(256) # 原始图片的概率密度rtos = np.zeros(256) # r-s对应关系hs = np.zeros(256) # 直方图均衡之后的灰度值thz = np.zeros(256) # 目标直方图灰度值tpz = np.zeros(256) # 目标直方图的概率密度rtoz = np.zeros(256) # r-z的对应关系Gz = np.zeros(256) # G(z)的值Zg = np.zeros(256) # G(z)的反函数hz = np.zeros(256) # 实际得到的匹配图像的直方图# 统计原始图片的直方图for row in range(H): for col in range(W): hr[img[row, col]] += 1# 直方图均衡# 先计算概率密度for i in range(256): pr[i] = hr[i] / (H * W)for i in range(256): # i=[0,255] temp = 0 for j in range(i + 1): # j=[0,i] temp += pr[j] rtos[i] = round(temp * 255) # 四舍五入取整hisImg = np.zeros((H, W, 3), np.uint8) # 建立直方图均衡变换之后的图片for row in range(H): for col in range(W): hisImg[row, col] = rtos[img[row, col]]# 统计均衡后的图片的直方图for row in range(H): for col in range(W): hs[hisImg[row, col]] += 1# 使用类似于图3.25a的概率分布图（估计值）# 对应的几个拐点# i thz# 0 0# 4 400000# 16 45600# 185 0# 205 34200# 255 0for i in range(256): if i &lt; 5: thz[i] = i * 100000 elif i &lt; 17: thz[i] = 518133 - 29533 * i elif i &lt; 186: thz[i] = 49950 - i * 270 elif i &lt; 206: thz[i] = 1710 * (i - 185) else: thz[i] = 684 * (255 - i)# 统计目标直方图的概率分布ztotal = np.sum(thz)for i in range(256): tpz[i] = thz[i] / ztotal# 计算G(z)的值，同样采用直方图均衡化方法for i in range(256): # i=[0,255] temp = 0 for j in range(i + 1): # j=[0,i] temp += tpz[j] Gz[i] = round(temp * 255) # 四舍五入取整# for i in range(256):# print(i, Gz[i])# 因为给出的概率分布没有水平线，所以Gz是单调递增的（除了一个点x=185）# 这里考虑没有单调增的情况，实现r-&gt;s-&gt;Gz-&gt;z的映射# 求G(z)的反函数，这样求出来的反函数可能会有某个Zg[i]==0for i in range(256): Zg[int(Gz[i])] = ifor i in range(1, 256): if Zg[i] == 0: for j in range(1, 256): # 如果Zg[i]为0，则从左右开始搜索最接近i的非零值，设置为Zg[i]的值 if i - j &gt;= 0 and Zg[i - j] != 0: Zg[i] = Zg[i - j] elif i + j &lt; 256 and Zg[i + j] != 0: Zg[i] = Zg[i + j] breakSpecifiedImg = np.zeros((H, W, 3), dtype=np.uint8) # 建立规定直方图变换之后的图片# 求出r-&gt;s-&gt;Gz-&gt;z的映射for i in range(256): rtoz[i] = Zg[int(rtos[i])]# 利用新的映射绘制新图for row in range(H): for col in range(W): SpecifiedImg[row, col] = rtoz[img[row, col]]# 统计真正匹配图像的直方图for row in range(H): for col in range(W): hz[SpecifiedImg[row, col]] += 1# print(hz)# 原图plt.subplot(2, 4, 1)plt.axis('off')plt.title('Original image')plt.imshow(img)# 原图的直方图plt.subplot(2, 4, 2)plt.bar(x, hr)plt.title('Histogram of original image')# 均衡后的图片plt.subplot(2, 4, 3)plt.axis('off')plt.title('After equalization')plt.imshow(hisImg)# r-&gt;s的变化函数# plt.subplot(3, 2, 4)# plt.title('s=T(r)')# plt.scatter(x, rtos)# 均衡化后的直方图plt.subplot(2, 4, 4)plt.title('Histogram after equalization')plt.bar(x, hs)# 目标直方图plt.subplot(2, 4, 5)plt.title('Specified histogram')plt.plot(x, thz)# Gz和Zgplt.subplot(2, 4, 6)plt.title('G(z) and its reverse')plt.plot(x, Gz, Zg)# 新的图片plt.subplot(2, 4, 7)plt.axis('off')plt.title('Specified Image')plt.imshow(SpecifiedImg)# 新的直方图plt.subplot(2, 4, 8)plt.title('Real specified histogram')plt.bar(x, hz)plt.show() 输出]]></content>
  </entry>
  <entry>
    <title><![CDATA[数字图像处理之仿射变换]]></title>
    <url>%2F2019%2F09%2F28%2F%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B9%8B%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[数字图像处理之仿射变换$$ \left[ \begin{matrix} 1 &amp; 2 &amp; 3 \ 4 &amp; 5 &amp; 6 \ 7 &amp; 8 &amp; 9 \end{matrix} \right] \tag{3}$$]]></content>
  </entry>
  <entry>
    <title><![CDATA[Numpy之random随机数]]></title>
    <url>%2F2019%2F09%2F20%2FNumpy%E4%B9%8Brandom%E9%9A%8F%E6%9C%BA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Numpy之random随机数numpy.random.rand() 原型: numpy.random.rand(d1,d2,…,dn) 参数：d0，d1，…，dn ： int，可选 作用：通过本函数可以返回一个或一组服从“0~1”均匀分布的随机样本值。随机样本取值范围是[0,1)，不包括1,返回数组的尺寸必须为非负数。如果没有给出参数，则返回单个Python float,如果给出参数，则已矩阵的形式返回 代码示例123456import numpy as npprint(np.random.rand())print(np.random.rand(1))print(np.random.rand(2))print(np.random.rand(3, 4)) 输出 1234560.09171627765988688[0.09575984][0.19469911 0.81856321][[0.28504605 0.81288214 0.32771727 0.32690197] [0.74796654 0.44727993 0.85740141 0.48064927] [0.82486295 0.73778363 0.89627339 0.49659976]] numpy.random.randn() 原型: numpy.random.randn(d1,d2,…,dn) 如果提供了正int_like参数，则randn生成一个形状数组，填充从均值0和方差1的单变量“正态”（高斯）分布中采样的随机浮点数。如果未提供参数，则返回从分布中随机抽样的单个浮点数。 参数： d0，d1，…，dn ： int，可选返回数组的尺寸必须为非负数。如果没有给出参数，则返回单个Python float。 返回： Z ： ndarray或漂浮来自标准正态分布的A 形浮点样本数组，如果没有提供参数，则为单个浮点数。 代码示例123456import numpy as npprint(np.random.randn())print(np.random.randn(1))print(np.random.randn(2))print(np.random.randn(3, 4)) 输出 12345[0.70899409][-0.13214787 0.8956988 ][[ 1.31895234 1.05841556 -0.05109841 -1.953933 ] [-0.68466894 1.83323997 -1.51220225 0.72683569] [ 1.19163007 0.2525111 -0.94921882 0.10838818]] 对于对于随机样本N（\ mu，\ sigma ^ 2），请使用： sigma * np.random.randn(...) + mu 123456import numpy as npsigma = 100mu = 10# N(100,10000)print(sigma * np.random.randn(2, 4) + mu) 输出 12[[ 120.83046615 55.68406043 -86.11764759 -149.7929397 ] [ -56.12066366 75.96162994 26.24926713 163.52869634]] numpy.random.randint() 原型：numpy.random.randint(low, high=None, size=None, dtype=’l’) 返回随机整数，范围区间为[low,high），包含low，不包含high 参数：low为最小值，high为最大值，size为数组维度大小，dtype为数据类型，默认的数据类型是np.int，high没有填写时，默认生成随机数的范围是[0，low) 参数： low ： int或类似int的数组要从分布中绘制的最低（有符号）整数（除非 high=None，在这种情况下，此参数是高于 最高此类整数的一个）。 high ： int或类似int的int，可选如果提供，则在从分布中提取的最大（有符号）整数之上（如果行为，请参见上文high=None）。如果是数组，则必须包含整数值 size ： int或int的元组，可选输出形状。如果给定的形状是例如，则 绘制样本。默认值为None，在这种情况下返回单个值。(m, n, k)m * n * k dtype ： dtype，可选期望的结果dtype。所有dtypes都由它们的名称决定，即’int64’，’int’等，因此byteorder不可用，并且具体的精度可能有不同的C类型，具体取决于平台。默认值为’np.int’。 返回：out ： int或ndarray of int来自适当分布的大小形状的随机整数数组，如果未提供大小，则为单个此类随机整数。 代码示例1234567import numpy as npprint(np.random.randint(1))print(np.random.randint(1, size=(2, 2)))print(np.random.randint(0, 10))print(np.random.randint(0, 10, size=(2, 5)))print(np.random.randint(1, 20, size=(4, 4), dtype='uint8')) 输出 123456789100[[0 0] [0 0]]7[[3 4 2 0 0] [1 6 3 1 2]][[17 15 19 8] [18 12 19 12] [ 2 3 15 15] [ 5 6 10 14]]]]></content>
  </entry>
  <entry>
    <title><![CDATA[Numpy之矩阵的堆叠与拆分]]></title>
    <url>%2F2019%2F09%2F10%2FNumpy%E4%B9%8B%E7%9F%A9%E9%98%B5%E7%9A%84%E5%A0%86%E5%8F%A0%E4%B8%8E%E6%8B%86%E5%88%86%2F</url>
    <content type="text"><![CDATA[Numpy之矩阵的堆叠与拆分矩阵的堆叠stack 原型：numpy.stack(arrary a, axis=0) 功能：矩阵堆叠扩展1个维度 代码实现123456789101112131415161718192021import numpy as npa=[[1,2,3], [4,5,6]]b=[[1,2,3], [4,5,6]]c=[[1,2,3], [4,5,6]]print("a=",a)print("b=",b)print("c=",c)print("增加一维，新维度的下标为0")d=np.stack((a,b,c),axis=0)print(d)print("增加一维，新维度的下标为1")d=np.stack((a,b,c),axis=1)print(d)print("增加一维，新维度的下标为2")d=np.stack((a,b,c),axis=2)print(d) 输出 12345678910111213141516171819202122232425262728a= [[1, 2, 3], [4, 5, 6]]b= [[1, 2, 3], [4, 5, 6]]c= [[1, 2, 3], [4, 5, 6]]增加一维，新维度的下标为0[[[1 2 3] [4 5 6]] [[1 2 3] [4 5 6]] [[1 2 3] [4 5 6]]]增加一维，新维度的下标为1[[[1 2 3] [1 2 3] [1 2 3]] [[4 5 6] [4 5 6] [4 5 6]]]增加一维，新维度的下标为2[[[1 1 1] [2 2 2] [3 3 3]] [[4 4 4] [5 5 5] [6 6 6]]] 123456789101112131415import numpy as npa=[1,2,3,4]b=[5,6,7,8]c=[9,10,11,12]print("a=",a)print("b=",b)print("c=",c)print("增加一维，新维度的下标为0")d=np.stack((a,b,c),axis=0)print(d)print("增加一维，新维度的下标为1")d=np.stack((a,b,c),axis=1)print(d) 123456789101112a= [1, 2, 3, 4]b= [5, 6, 7, 8]c= [9, 10, 11, 12]增加一维，新维度的下标为0[[ 1 2 3 4] [ 5 6 7 8] [ 9 10 11 12]]增加一维，新维度的下标为1[[ 1 5 9] [ 2 6 10] [ 3 7 11] [ 4 8 12]] vstack 原型：numpy.vstack(array a, array b) 功能：把b矩阵在a的基础上扩充行 代码实现123456789import numpy as npa = np.floor(10*np.random.random((3, 3)))print(a)print("=================")b = np.floor(10*np.random.random((3, 3)))print(b)print("=================")print(np.vstack((a, b))) 输出 1234567891011121314[[6. 8. 3.] [8. 7. 3.] [2. 4. 4.]]=================[[3. 9. 3.] [1. 3. 9.] [1. 8. 4.]]=================[[6. 8. 3.] [8. 7. 3.] [2. 4. 4.] [3. 9. 3.] [1. 3. 9.] [1. 8. 4.]] hstack 原型：numpy.hstack(array a, array b) 功能：把b矩阵在a的基础上扩充列 代码实现123456789import numpy as npa = np.floor(10*np.random.random((3, 3)))print(a)print("=================")b = np.floor(10*np.random.random((3, 3)))print(b)print("=================")print(np.hstack((a, b))) 输出 1234567891011[[6. 8. 3.] [8. 7. 3.] [2. 4. 4.]]=================[[3. 9. 3.] [1. 3. 9.] [1. 8. 4.]]=================[[6. 8. 3. 3. 9. 3.] [8. 7. 3. 1. 3. 9.] [2. 4. 4. 1. 8. 4.]] column_stack 原型：numpy.column_stack(array a) 功能：将一维矩阵作为列堆叠成二维矩阵 代码实现1234567891011121314151617181920212223import numpy as npfrom numpy import newaxisa = np.floor(10*np.random.random((3, 3)))print(a)print("=================")b = np.floor(10*np.random.random((3, 3)))print(b)print("=================")print(np.column_stack((a, b)))print("=================")a = np.array([4., 2.])b = np.array([3., 8.])print(np.column_stack((a, b)))print("=================")print(a[:, newaxis])print("=================")print(b[:, newaxis])print("=================")print(np.column_stack((a[:, newaxis], b[:, newaxis])))print("=================")print(np.hstack((a[:, newaxis], b[:, newaxis])))print("=================") 输出 123456789101112131415161718192021222324252627[[3. 5. 6.] [3. 2. 4.] [6. 3. 5.]]=================[[2. 2. 0.] [0. 3. 5.] [7. 4. 7.]]=================[[3. 5. 6. 2. 2. 0.] [3. 2. 4. 0. 3. 5.] [6. 3. 5. 7. 4. 7.]]=================[[4. 3.] [2. 8.]]=================[[4.] [2.]]=================[[3.] [8.]]=================[[4. 3.] [2. 8.]]=================[[4. 3.] [2. 8.]]================= 矩阵的拆分hsplit 原型：numpy.hsplit(ary, indices_or_sections) 功能：将数组拆分为多个大小相等的子数组。使用hsplit，通过指定要返回的相同shape的array的数量，或者通过指定分割应该发生之后的列来沿着其横轴拆分原array 代码实现12345678import numpy as npx = np.arange(16.0).reshape(4, 4)print(x)print("=================")print(np.hsplit(x, 2))print("=================")print(np.hsplit(x, np.array([3, 6]))) 输出 1234567891011121314151617181920[[ 0. 1. 2. 3.] [ 4. 5. 6. 7.] [ 8. 9. 10. 11.] [12. 13. 14. 15.]]=================[array([[ 0., 1.], [ 4., 5.], [ 8., 9.], [12., 13.]]), array([[ 2., 3.], [ 6., 7.], [10., 11.], [14., 15.]])]=================[array([[ 0., 1., 2.], [ 4., 5., 6.], [ 8., 9., 10.], [12., 13., 14.]]), array([[ 3.], [ 7.], [11.], [15.]]), array([], shape=(4, 0), dtype=float64)] vstack 原型：numpy.vstack(ary, indices_or_sections) 功能：vsplit沿着垂直轴分割，其分割方式与hsplit用法相同。 代码实现12345678import numpy as npx = np.arange(16.0).reshape(4, 4)print(x)print("=================")print(np.vsplit(x, 2))print("=================")print(np.vsplit(x, np.array([3, 6]))) 输出 123456789101112[[ 0. 1. 2. 3.] [ 4. 5. 6. 7.] [ 8. 9. 10. 11.] [12. 13. 14. 15.]]=================[array([[0., 1., 2., 3.], [4., 5., 6., 7.]]), array([[ 8., 9., 10., 11.], [12., 13., 14., 15.]])]=================[array([[ 0., 1., 2., 3.], [ 4., 5., 6., 7.], [ 8., 9., 10., 11.]]), array([[12., 13., 14., 15.]]), array([], shape=(0, 4), dtype=float64)]]]></content>
  </entry>
  <entry>
    <title><![CDATA[浅谈Numpy的shape和reshape]]></title>
    <url>%2F2019%2F09%2F10%2F%E6%B5%85%E8%B0%88Numpy%E7%9A%84shape%E5%92%8Creshape%2F</url>
    <content type="text"><![CDATA[浅谈Numpy的shape和reshape@[toc] shape 原型：numpy.shape(array) shape 是 array的一个属性，它能获取矩阵的行列的维度 123456import numpy as nparray1 = np.array([[1,2,3],[4,5,6]])print(array1.shape)array2 = np.array([[2,4],[6,8],[0,12]])print(np.shape(array2)) 输出 12(2, 3)(3, 2) reshape 原型：numpy.reshape(array,newshape,order=’c’) array：原矩阵 newshape：整数值或整数元组。新的形状应该兼容于原始形状。如果是一个整数值，表示一个一维数组的长度；如果是元组，表示新数组的行和列数，一个元素值可以为-1，此时该元素值表示为指定，此时会从数组的长度和剩余的维度中推断出 order： {‘C’，’F’，’A’}，可选使用此索引顺序读取a的元素，并使用此索引顺序将元素放入reshape d数组中。“C”表示使用类似C的索引顺序读取/写入元素，最后一个轴索引变化最快，返回到第一个轴索引变化最慢。’F’表示使用类似Fortran的索引顺序读/写元素，第一个索引变化最快，最后一个索引变化最慢。请注意，“C”和“F”选项不考虑底层数组的内存布局，只涉及索引的顺序。’A’表示以类似Fortran的索引顺序读取/写入元素，如果a在内存中是Fortran 连续的，否则是C-like顺序。 12345import numpy as nparray = np.array([[2,4],[6,8],[0,12]])print(array)print(array.reshape((2, 3)))print(array) 输出 12345678 [[ 2 4] [ 6 8] [ 0 12]][[ 2 4 6] [ 8 0 12]][[ 2 4] [ 6 8] [ 0 12]]]]></content>
  </entry>
  <entry>
    <title><![CDATA[OpenCV-Python小白进阶之鼠标事件]]></title>
    <url>%2F2019%2F08%2F31%2FOpenCV-Python%E5%B0%8F%E7%99%BD%E8%BF%9B%E9%98%B6%E4%B9%8B%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[OpenCV-Python小白进阶之鼠标事件🖱鼠标️事件 EVENT_MOUSEMOVE 0 #滑动 EVENT_LBUTTONDOWN 1 #左键点击 EVENT_RBUTTONDOWN 2 #右键点击 EVENT_MBUTTONDOWN 3 #中键点击 EVENT_LBUTTONUP 4 #左键放开 EVENT_RBUTTONUP 5 #右键放开 EVENT_MBUTTONUP 6 #中键放开 EVENT_LBUTTONDBLCLK 7 #左键双击 EVENT_RBUTTONDBLCLK 8 #右键双击 EVENT_MBUTTONDBLCLK 9 #中键双击 函数 setMouseCallback（winname,onMouse,userdata） winname 窗口名称 onMouse 鼠标事件的回调函数。有关如何指定和使用回调的信息 userdata 传递给回调的可选参数 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546# coding:utf-8import cv2import numpy as npdrawing = False # 如果按下鼠标，则为truemode = True # 如果为True，则绘制矩形。按'm'切换到曲线ix = -1iy = -1def draw(event, x, y, flag, parm): global ix, iy, drawing, mode if event == cv2.EVENT_LBUTTONDOWN: drawing = True ix = x iy = y elif event == cv2.EVENT_MOUSEMOVE: if drawing: if mode: cv2.rectangle(img, (ix, iy), (x, y), (0, 255, 0), -1) else: cv2.circle(img, (ix, iy), 50, (0, 0, 255), -1) elif event == cv2.EVENT_LBUTTONUP: drawing = False if mode: cv2.rectangle(img, (ix, iy), (x, y), (0, 255, 0), -1) else: cv2.circle(img, (ix, iy), 50, (0, 0, 255), -1)img = np.zeros((512, 512, 3), np.uint8)cv2.namedWindow('image')cv2.setMouseCallback('image', draw)while True: cv2.imshow('image', img) k = cv2.waitKey(1) &amp; 0xff if k == ord('m'): mode = not mode elif k == 27: breakcv2.destroyAllWindows()]]></content>
  </entry>
  <entry>
    <title><![CDATA[OpenCV-Python小白进阶之简单的绘图操作]]></title>
    <url>%2F2019%2F08%2F23%2FOpenCV-Python%E5%B0%8F%E7%99%BD%E8%BF%9B%E9%98%B6%E4%B9%8B%E7%AE%80%E5%8D%95%E7%9A%84%E7%BB%98%E5%9B%BE%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[OpenCV-Python小白进阶之简单的绘图操作line()原型： img=cv2.line(img, pt1, pt2, color[, thickness[, lineType[, shift]]]) 参数 img 图片 pt1 线段的第一点 pt2 线段的第二点 color 线条颜色 thickness 线的粗细 lineType 线的类型 shift 点坐标中的小数位数 123456789101112import cv2import numpy as npimg = np.zeros((512, 512, 3), np.uint8)cv2.line(img, (0, 0), (511, 511), (255, 0, 0), 5)while True: cv2.imshow('image', img) if cv2.waitKey(1) == 27: breakcv2.destroyAllWindows() rectangle()原型： img =cv2.rectangle(img, pt1, pt2, color[, thickness[, lineType[, shift]]]) img =cv2.rectangle(img, rec, color[, thickness[, lineType[, shift]]]) Parameters img 图片 pt1 矩形的顶点 pt2 矩形的顶点与pt1相对 color 矩形颜色或亮度（灰度图像） thickness 构成矩形的线条的粗细。负值（如FILLED）表示函数必须绘制填充矩形 lineType 线的类型。请参见LineTypes 12345678910111213import cv2import numpy as npimg = np.zeros((512, 512, 3), np.uint8)cv2.line(img, (0, 0), (511, 511), (255, 0, 0), 5)cv2.rectangle(img, (384, 0), (510, 128), (0, 255, 0), 3)while True: cv2.imshow('image', img) if cv2.waitKey(1) == 27: breakcv2.destroyAllWindows() circle()原型： img = cv2.circle(img, center, radius, color[, thickness[, lineType[, shift]]] ) Parameters img 绘制圆的图像 center 圆心 radius 圆的半径 color 圆形颜色 thickness 圆形轮廓的厚度，如果是正的。负值（如FILLED）表示要绘制实心圆。 lineType 圆边界的类型。请参见LineTypes shift 中心坐标和半径值中的小数位数 123456789101112131415import cv2import numpy as npimg = np.zeros((512, 512, 3), np.uint8)cv2.line(img, (0, 0), (511, 511), (255, 0, 0), 5)cv2.rectangle(img, (384, 0), (510, 128), (0, 255, 0), 3)cv2.circle(img, (447, 63), 63, (0, 0, 255), 3)while True: cv2.imshow('image', img) if cv2.waitKey(1) == 27: breakcv2.destroyAllWindows() elipse()原型： img =cv2.ellipse(img, center, axes, angle, startAngle, endAngle, color[, thickness[, lineType[, shift]]]) img =cv2.ellipse(img, box, color[, thickness[, lineType]]) Parameters img 图片 center 椭圆的中心 axes 椭圆主轴大小的一半 angle 椭圆旋转角度（以度为单位) startAngle 椭圆弧的起始角度（以度为单位) endAngle 椭圆颜色 color 椭圆弧的轮廓粗细，如果是正的。否则，这表示将绘制填充的椭圆扇区 thickness 椭圆弧的轮廓粗细，如果是正的。否则，这表示将绘制填充的椭圆扇区。 lineType 椭圆边界的类型。请参见LineTypes shift 中心坐标和轴值的小数位数 12345678910111213141516import cv2import numpy as npimg = np.zeros((512, 512, 3), np.uint8)cv2.line(img, (0, 0), (511, 511), (255, 0, 0), 5)cv2.rectangle(img, (384, 0), (510, 128), (0, 255, 0), 3)cv2.circle(img, (447, 63), 63, (0, 0, 255), 3)cv2.ellipse(img, (256, 256), (100, 50), 0, 0, 180, 255, -1)while True: cv2.imshow('image', img) if cv2.waitKey(1) == 27: breakcv2.destroyAllWindows() ploylines()原型： img=cv2.polylines(img, pts, isClosed, color[, thickness[, lineType[, shift]]]) Parameters img 图片 pts 多边形曲线的数组 isClosed 指示绘制的折线是否关闭的标记。如果它们被关闭，则该函数从每条曲线的最后一个顶点到其第一个顶点绘制一条线 color 折线颜色 thickness 折线边缘的厚度 lineType 线段的类型 请参见LineTypes shift 顶点坐标中的小数位数 1234567891011121314151617181920import cv2import numpy as npimg = np.zeros((512, 512, 3), np.uint8)cv2.line(img, (0, 0), (511, 511), (255, 0, 0), 5)cv2.rectangle(img, (384, 0), (510, 128), (0, 255, 0), 3)cv2.circle(img, (447, 63), 63, (0, 0, 255), 3)cv2.ellipse(img, (256, 256), (100, 50), 0, 0, 180, 255, -1)pts = np.array([[10, 5], [20, 30], [70, 20], [50, 10]], np.int32)pts = pts.reshape((-1, 1, 2))cv2.polylines(img, [pts], True, (0,255,255))while True: cv2.imshow('image', img) if cv2.waitKey(1) == 27: breakcv2.destroyAllWindows() putText()原型： img = cv.putText(img, text, org, fontFace, fontScale, color[, thickness[, lineType[, bottomLeftOrigin]]]) img 图片 text 要绘制的文本字符串 org 图像中文本字符串的左下角 fontFace 字体类型 fontScale 字体比例因子乘以字体特定的基本大小 color 文字颜色 thickness 用于绘制文本的线条的粗细 lineType 线型 bottomLeftOrigin 如果为true，则图像数据原点位于左下角。否则，它位于左上角。 1234567891011121314151617181920212223import cv2import numpy as npimg = np.zeros((512, 512, 3), np.uint8)cv2.line(img, (0, 0), (511, 511), (255, 0, 0), 5)cv2.rectangle(img, (384, 0), (510, 128), (0, 255, 0), 3)cv2.circle(img, (447, 63), 63, (0, 0, 255), 3)cv2.ellipse(img, (256, 256), (100, 50), 0, 0, 180, 255, -1)pts = np.array([[10, 5], [20, 30], [70, 20], [50, 10]], np.int32)pts = pts.reshape((-1, 1, 2))cv2.polylines(img, [pts], True, (0,255,255))font = cv2.FONT_HERSHEY_COMPLEXcv2.putText(img, 'OpenCV', (10, 500), font, 4, (255, 255, 255), 2, cv2.LINE_AA)while True: cv2.imshow('image', img) if cv2.waitKey(1) == 27: breakcv2.destroyAllWindows()]]></content>
  </entry>
  <entry>
    <title><![CDATA[OpenCV-Python小白进阶之图片的融合]]></title>
    <url>%2F2019%2F08%2F18%2FOpenCV-Python%E5%B0%8F%E7%99%BD%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%9B%BE%E7%89%87%E7%9A%84%E8%9E%8D%E5%90%88%2F</url>
    <content type="text"><![CDATA[OpenCV-Python小白进阶之图片的融合方法cv2.resize() https://wgowi.github.io/2019/08/18/OpenCV-Python%E5%B0%8F%E7%99%BD%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%9B%BE%E7%89%87%E7%9A%84%E4%BC%B8%E7%BC%A9%E5%8F%98%E6%8D%A2/#more cv2.addWeighted(img1, x, img2, y, 0) 把img1与img2按xy的比重融合 cv2.add(img1,img2) 将img1与img2按1:1融合 代码实现1234567891011121314151617181920import cv2img1 = cv2.imread('a.jpg')img2 = cv2.imread('cv.jpg')img3 = cv2.resize(img1, (400, 400))img4 = cv2.resize(img2, (400, 400))img5 = cv2.addWeighted(img3, 0.5, img4, 0.5, 0)img6 = cv2.add(img3,img4)img7 = cv2.addWeighted(img4, 1, img3, 1, 0)cv2.imshow('img5', img5)cv2.imshow('img6', img6)cv2.imshow('img7', img7)while True: if cv2.waitKey(1) == 27: breakcv2.destroyAllWindows() 由此可知cv2.addweighted()img1和img2的比重都为1时与cv2.add()相同]]></content>
  </entry>
  <entry>
    <title><![CDATA[OpenCV-Python小白进阶之图片的伸缩变换]]></title>
    <url>%2F2019%2F08%2F18%2FOpenCV-Python%E5%B0%8F%E7%99%BD%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%9B%BE%E7%89%87%E7%9A%84%E4%BC%B8%E7%BC%A9%E5%8F%98%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[OpenCV-Python小白进阶之图片的伸缩变换方法 cv2.resize(InputArray src, OutputArray dst, Size, fx, fy, interpolation) 参数： InputArray src：输入图片 OutputArray dst：输出图片 Size：输出图片尺寸 fx, fy： 沿x轴，y轴的缩放系数 interpolation： 插入方式 interpolation： 选项所用的插值方法： INTER_NEAREST：最近邻插值 INTER_LINEAR：双线性插值（默认设置） INTER_AREA：使用像素区域关系进行重采样。 INTER_CUBIC：4x4像素邻域的双三次插值 INTER_LANCZOS4：8x8像素邻域的Lanczos插值 代码实现 12345678910111213141516 import cv2img0 = cv2.imread('a.jpg')img1 = cv2.resize(img0, (600, 400), interpolation=cv2.INTER_NEAREST)img2 = cv2.resize(img0, (0,0),fx=0.1, fy=0.1, interpolation=cv2.INTER_NEAREST)img3 = cv2.resize(img2,(0,0),fx=2,fy=2, interpolation=cv2.INTER_NEAREST)cv2.imshow('img0',img0)cv2.imshow('img1',img1)cv2.imshow('img2',img2)cv2.imshow('img3',img3)while (True): if cv2.waitKey(0) == 27: breakcv2.destroyAllWindows()]]></content>
  </entry>
  <entry>
    <title><![CDATA[OpenCV-Python小白进阶之位运算与掩膜]]></title>
    <url>%2F2019%2F08%2F18%2FOpenCV-Python%E5%B0%8F%E7%99%BD%E8%BF%9B%E9%98%B6%E4%B9%8B%E4%BD%8D%E8%BF%90%E7%AE%97%E4%B8%8E%E6%8E%A9%E8%86%9C%2F</url>
    <content type="text"><![CDATA[OpenCV-Python小白进阶之位运算与掩膜位运算 由于图片是有一个个0和1组成的，所以OpenCV中对图像也支持为运算（与或非等） 1234dst = cv2.bitwise_and(src1，src2[，dst[，mask]])dst = cv2.bitwise_not(src[, dst[, mask]])dst = cv2.bitwise_or(src1, src2[, dst[, mask]])dst = cv2.bitwise_xor(src1, src2[, dst[, mask]]) bitwise_and是对二进制数据进行“与”操作，即对图像（灰度图像或彩色图像均可）每个像素值进行二进制“与”操作，1&1=1，1&0=0，0&1=0，0&0=0 bitwise_or是对二进制数据进行“或”操作，即对图像（灰度图像或彩色图像均可）每个像素值进行二进制“或”操作，1|1=1，1|0=0，0|1=0，0|0=0 bitwise_xor是对二进制数据进行“异或”操作，即对图像（灰度图像或彩色图像均可）每个像素值进行二进制“异或”操作，1^1=0,1^0=1,0^1=1,0^0=0 bitwise_not是对二进制数据进行“非”操作，即对图像（灰度图像或彩色图像均可）每个像素值进行二进制“非”操作，1=0，0=1 123456789101112131415161718192021222324252627282930313233import numpy as npimport cv2img = cv2.imread('cv.jpg')# cv2.imshow('image',img)rectangle = np.zeros(img.shape[0:2], dtype='uint8')cv2.rectangle(rectangle, (25, 25), (275, 275), 255, -1)cv2.imshow('rectangle', rectangle)circle = np.zeros(img.shape[0:2], dtype='uint8')cv2.circle(circle, (150, 150), 150, 255, -1)cv2.imshow('circle', circle)bit_and = cv2.bitwise_and(rectangle, circle)cv2.imshow('and', bit_and)bit_or = cv2.bitwise_or(rectangle, circle)cv2.imshow('or', bit_or)bit_xor = cv2.bitwise_xor(rectangle, circle)cv2.imshow('xor', bit_xor)bit_not1 = cv2.bitwise_not(rectangle)cv2.imshow('not1', bit_not1)bit_not2 = cv2.bitwise_not(circle)cv2.imshow('not2', bit_not2)while (True): if cv2.waitKey(0)==27: breakcv2.destroyAllWindows() 掩膜用选定的图像、图形或物体，对处理的图像（全部或局部）进行遮挡，来控制图像处理的区域或处理过程。用于覆盖的特定图像或物体称为掩模或模板。光学图像处理中,掩模可以是胶片、滤光片等。数字图像处理中,掩模为二维矩阵数组,有时也用多值图像。 数字图像处理中，图像掩模主要用于： ①提取感兴趣区,用预先制作的感兴趣区掩模与待处理图像相乘,得到感兴趣区图像,感兴趣区内图像值保持不变,而区外图像值都为0。 ②屏蔽作用,用掩模对图像上某些区域作屏蔽,使其不参加处理或不参加处理参数的计算,或仅对屏蔽区作处理或统计。 ③结构特征提取,用相似性变量或图像匹配方法检测和提取图像中与掩模相似的结构特征。 ④特殊形状图像的制作。掩膜是一种图像滤镜的模板，实用掩膜经常处理的是遥感图像。当提取道路或者河流，或者房屋时，通过一个n*n的矩阵来对图像进行像素过滤，然后将我们需要的地物或者标志突出显示出来。这个矩阵就是一种掩膜。 12345678910111213141516171819202122232425import cv2 as cvcv.namedWindow('image', 0)cv.resizeWindow('image', 720, 480)# 加载两张图片img1 = cv.imread('a.jpg')img2 = cv.imread('a.jpeg')# 我想在左上角放置标识，所以我创建了一个ROIrows,cols,channels = img2.shaperoi = img1[0:rows, 0:cols ]# 现在创建一个徽标掩码并创建其反转掩码img2gray = cv.cvtColor(img2,cv.COLOR_BGR2GRAY)ret, mask = cv.threshold(img2gray, 10, 255, cv.THRESH_BINARY)mask_inv = cv.bitwise_not(mask)# 现在使ROI中的徽标区域变黑img1_bg = cv.bitwise_and(roi,roi,mask = mask_inv)# 仅从徽标图像中获取徽标区域。img2_fg = cv.bitwise_and(img2,img2,mask = mask)# 在ROI中放置徽标并修改主图像dst = cv.add(img1_bg,img2_fg)img1[0:rows, 0:cols ] = dstcv.imshow('image',img1)cv.waitKey(0)cv.destroyAllWindows()]]></content>
  </entry>
  <entry>
    <title><![CDATA[OpenCv-Python小白进阶之进度条createTrackbar]]></title>
    <url>%2F2019%2F08%2F17%2FOpenCv-Python%E5%B0%8F%E7%99%BD%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%BF%9B%E5%BA%A6%E6%9D%A1createTrackbar%2F</url>
    <content type="text"><![CDATA[OpenCv-Python小白进阶之进度条createTrackbarcreateTrackbarint createTrackbar(const string&amp; trackbarname, const string&amp;winname, int* value, int count ，TrackbarCallback onChange = 0, void* userdata = 0) 参数1：轨迹条名字 参数2：窗口名字 参数3：滑块初始位置 参数4：表示滑块达到最大位置的值 参数5：默认值为0，指向回调函数 参数6：默认值为0，用户传给回调函数的数据值 getTrackbarint getTrackbarPos(const string&amp; trackbarname, const string&amp; winname) 函数作用： 获取滑动条的位置的值 参数1:进度条名称 参数2:窗口名称 返回值：进度条位置 代码实现12345678910111213141516171819202122# -*- coding:utf-8 -*-import cv2img = cv2.imread('a.jpg', 0)print img.sizeprint img.dtypecv2.namedWindow('image', 0)cv2.resizeWindow('image', 720, 480)cv2.createTrackbar('num','image',0,255,lambda x: None)while(True): num = cv2.getTrackbarPos('num','image') ret, thresh1 = cv2.threshold(img, num, 255, cv2.THRESH_BINARY) cv2.imshow('image', thresh1) if cv2.waitKey(1) == 27: breakcv2.destroyAllWindows()]]></content>
  </entry>
  <entry>
    <title><![CDATA[OpenCV-Python小白进阶之图像固定阈值二值化处理threshold]]></title>
    <url>%2F2019%2F08%2F17%2FOpenCV-Python%E5%B0%8F%E7%99%BD%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%9B%BE%E5%83%8F%E5%9B%BA%E5%AE%9A%E9%98%88%E5%80%BC%E4%BA%8C%E5%80%BC%E5%8C%96%E5%A4%84%E7%90%86threshold%2F</url>
    <content type="text"><![CDATA[OpenCV-Python小白进阶之图像固定阈值二值化处理threshold二值化定义：图像的二值化，就是将图像上的像素点的灰度值设置为0或255，也就是将整个图像呈现出明显的只有黑和白的视觉效果。灰度值0：黑，灰度值255：白 一幅图像包括目标物体、背景还有噪声，要想从多值的数字图像中直接提取出目标物体，常用的方法就是设定一个阈值T，用T将图像的数据分成两部分：大于T的像素群和小于T的像素群。这是研究灰度变换的最特殊的方法，称为图像的二值化（Binarization）。 threshold cv2.threshold(img, threshold, maxval,type) 其中： threshold是设定的阈值 maxval是当灰度值大于（或小于）阈值时将该灰度值赋成的值 type规定的是当前二值化的方式 代码实现123456789101112131415161718192021222324# -*- coding:utf-8 -*-import cv2img1 = cv2.imread('opencv.png', cv2.IMREAD_GRAYSCALE)# cv2.THRESH_OTSU 作为图像自适应二值化的一个很优的算法Otsu大津算法的参数ret, binary = cv2.threshold(img1, 175, 255, cv2.THRESH_BINARY)# cv2.THRESH_BINARY 大于阈值的部分被置为255，小于部分被置为0ret, binaryinv = cv2.threshold(img1, 175, 255, cv2.THRESH_BINARY_INV)# cv2.THRESH_BINARY_INV 大于阈值部分被置为0，小于部分被置为255ret, trunc = cv2.threshold(img1, 175, 255, cv2.THRESH_TRUNC)# cv2.THRESH_TRUNC 大于阈值部分被置为threshold，小于部分保持原样ret, tozero = cv2.threshold(img1, 175, 255, cv2.THRESH_TOZERO)# cv2.THRESH_TOZERO 小于阈值部分被置为0，大于部分保持不变ret, tozeroinv = cv2.threshold(img1, 175, 255, cv2.THRESH_TOZERO_INV)# cv2.THRESH_TOZERO_INV 大于阈值部分被置为0，小于部分保持不变while True: cv2.imshow('img1', img1) cv2.imshow('binary', binary) cv2.imshow('binaryinv', binaryinv) cv2.imshow('trunc', trunc) cv2.imshow('tozero', tozero) cv2.imshow('tozeroinv', tozeroinv) if cv2.waitKey(1) == 27: break]]></content>
  </entry>
  <entry>
    <title><![CDATA[OpenCV-Python小白进阶之获取像素点]]></title>
    <url>%2F2019%2F08%2F16%2FOpenCV-Python%E5%B0%8F%E7%99%BD%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%8E%B7%E5%8F%96%E5%83%8F%E7%B4%A0%E7%82%B9%2F</url>
    <content type="text"><![CDATA[OpenCV-Python小白进阶之获取像素点灰度图因为灰度图不具有RGB值，所以的img是一个二维数组，第一维表示行，第二维表示列 代码实现 12print img.shapeprint img[1][1] 彩色图因为彩色图具有RGB值，所以的img是一个三维数组，第一维表示行，第二维表示列，第三维表示RGB通道,0表示b，1表示g，2表示r 代码实现12print img.shapeprint img[1][1][1]]]></content>
  </entry>
  <entry>
    <title><![CDATA[OpenCV-Python小白进阶之灰度转化、分离RGB与直方图显示]]></title>
    <url>%2F2019%2F08%2F15%2FOpenCV-Python%E5%B0%8F%E7%99%BD%E8%BF%9B%E9%98%B6%E4%B9%8B%E7%81%B0%E5%BA%A6%E8%BD%AC%E5%8C%96%E3%80%81%E5%88%86%E7%A6%BBRGB%E4%B8%8E%E7%9B%B4%E6%96%B9%E5%9B%BE%E6%98%BE%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[OpenCV-Python小白进阶之灰度转化、分离RGB与直方图显示@[toc] 条件环境：OpenCV Pycharm python3.7素材： 转化为灰度图函数： cv2.imread(path) 载入图片 cv2.cvtColor(img, cv2.COLOR_RGB2GRAY) 把img图片从RGB格式切换为GRAY cv2.namedWindow(name, aotusize) 给窗口命名，大小不可自由调整 cv2.resizeWindow(name, length, width) 给窗口设置长与宽 cv2.imshow(name, img) 显示img图片 cv2.imwrite(path, img) 创建path路径并写入img图片 代码实现123456789import cv2img = cv2.imread('p1.jpg')img0 = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)cv2.imwrite('p2.jpg', img0)cv2.namedWindow('figure1', 0)cv2.resizeWindow('figure1', 960, 480)cv2.imshow('figure1', img0) 输出 分离RGB函数 cv2.split(img) 分离img图片的RGB，注意！！！电脑是以BGR的顺序分离的 代码实现123456789101112131415161718192021222324import cv2import matplotlib.pyplot as pltimg = cv2.imread('p1.jpg')img0 = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)cv2.imwrite('p2.jpg', img0)cv2.namedWindow('figure1', 0)cv2.resizeWindow('figure1', 960, 480)cv2.imshow('figure1', img0)for col in ['Blue', "Green", 'Red']: cv2.namedWindow(col, 0) cv2.resizeWindow(col, 960, 480)b, g, r = cv2.split(img)cv2.imwrite('Blue.jpg', b)cv2.imwrite('Red.jpg', r)cv2.imwrite('Green.jpg', g)cv2.imwrite('Blue.jpg', b)cv2.imwrite('Red.jpg', r)cv2.imwrite('Green.jpg', g)cv2.destroyAllWindows() 输出redblueGreen 直方图显示函数 cv2.calcHist(images, channels, mask, histSize, ranges[, hist[, accumulate ]]) 第一个参数必须用方括号括起来。 第二个参数是用于计算直方图的通道，这里使用灰度图计算直方图，所以就直接使用第一个通道； 第三个参数是Mask，这里没有使用，所以用None。 第四个参数是histSize，表示这个直方图分成多少份（即多少个直方柱）。第二个例子将绘出直方图，到时候会清楚一点。 第五个参数是表示直方图中各个像素的值，[0.0, 256.0]表示直方图能表示像素值从0.0到256的像素。 代码实现12345678910111213141516171819202122232425262728293031323334353637import cv2import matplotlib.pyplot as pltimg = cv2.imread('p1.jpg')img0 = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)cv2.imwrite('p2.jpg', img0)cv2.namedWindow('figure1', 0)cv2.resizeWindow('figure1', 960, 480)cv2.imshow('figure1', img0)for col in ['Blue', "Green", 'Red']: cv2.namedWindow(col, 0) cv2.resizeWindow(col, 960, 480)b, g, r = cv2.split(img)cv2.imwrite('Blue.jpg', b)cv2.imwrite('Red.jpg', r)cv2.imwrite('Green.jpg', g)r = cv2.imshow("Red", r)g = cv2.imshow("Green", g)b = cv2.imshow("Blue", b)cv2.destroyAllWindows()color = ['b', 'g', 'r']for i, col in enumerate(color): histr = cv2.calcHist([img], [i], None, [256], [0, 256]) plt.plot(histr, color=col) plt.xlim(0, 256) plt.ylim(0, 700000) plt.show()histr = cv2.calcHist([img0], [0], None, [256], [0, 256])plt.plot(histr, color=col)plt.xlim(0, 256)plt.ylim(0, 700000)plt.show() 输出]]></content>
  </entry>
  <entry>
    <title><![CDATA[浅谈减而治之与分而治之]]></title>
    <url>%2F2019%2F08%2F12%2F%E6%B5%85%E8%B0%88%E5%87%8F%E8%80%8C%E6%B2%BB%E4%B9%8B%E4%B8%8E%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B%2F</url>
    <content type="text"><![CDATA[浅谈减而治之与分而治之@[toc] 减而治之线性递归（linear recursion）即减而治之（decrease-and-conquer）的思想：递归每深入一层，待求解问题的规模都缩减一个常数，直至最终蜕化为平凡的小（简单）问题。将一个规模为n的大问题退化为一个规模为n-1的小问题，直至退化为规模为1的平凡情况，这种情况称之为递归基（base case of recursion），当达到递归基时,算法将执行非递归计算。这一方法体现了算法的有穷性。一般这种问题可以分为两个独立的子问题，其一用于单独的一个元素（如：递归出口），其二应用于剩余部分结构与原问题相同。子问题经合并后为原问题的解。 1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;int Fib(int n)&#123; if (n==1||n==0) &#123; return 1;//递归出口 &#125; else &#123; return Fib(n-1)+Fib(n-2);//把问题分解成Fib(n-1)+Fib(n-2)来递归求解 &#125;&#125;int main()&#123; int n; cin&gt;&gt;n; cout&lt;&lt;Fib(n)&lt;&lt;endl; return 0;&#125; 分而治之二分递归（binary recursion）即分而治之（divide-and-conquer）的思想：将其分解为若干规模更小的子问题， 再通过递归机制分别求解。 这种分解持续进行，直到子问题规模缩减至平凡情况。在这种情况下，每一递归实例会调用多个递归来完成，故称作多路递归（multi-way recursion），通常都是将原问题一分为二，故有二分递归。以下代码是对数组求和的二分递归的实现，新算法的思路是：以居中的元素为界将数组一分为二；递归地对子数组分别求和；最后，子数组之和相加即为原数组的总和。 可以用二路归并来理解下面以vector的二路归并为例 123456789101112131415161718192021222324252627282930313233343536373839template &lt;typename T&gt;void Vector&lt;T&gt;::mergeSort(Rank lo, Rank hi)&#123; if (hi-lo&lt;2) &#123; return; &#125; int mi=(lo+hi)&gt;&gt;2; mergeSort(lo, mi); mergeSort(mi, hi); merge(lo, mi, hi);&#125;template &lt;typename T&gt;void Vector&lt;T&gt;::merge(Rank lo, Rank mi, Rank hi)&#123; T* A=_elem+lo; int lb=mi-lo; T* B=new T[lb]; for (Rank i=0; i&lt;lb; i++) &#123; B[i]=A[i]; &#125; int lc=hi-mi; T* C=_elem+mi; for (Rank i=0,j=0,k=0; j&lt;lb;i++ ) &#123; if ((lc&lt;=k)||(B[j]&lt;=C[k])) &#123; A[i]=B[j++]; &#125; if ((k&lt;lc)&amp;&amp;(C[k]&lt;B[j])) &#123; A[i]=C[k++]; &#125; &#125; delete [] B;&#125; 大致内容如图所示：二路归并的意义在于把一个无序的向量分解成单个有序的元素，然后两两归并排序成为一个有序的向量，所以可以递归。二路归并体现了分而治之的思想。把一个向量一分为二，慢慢的变成单个的元素将问题缩减成很简单的情况。然后排序归并。 参考链接：https://juejin.im/post/5b9f8ffae51d450e83776059]]></content>
  </entry>
  <entry>
    <title><![CDATA[C++多重继承的构造与析构的顺序]]></title>
    <url>%2F2019%2F08%2F12%2FC-%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E7%9A%84%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84%E7%9A%84%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[C++多重继承的构造与析构的次序在C++的多重继承中含有虚基类，成员对象时很容易把构造与析构的顺序弄不清楚 下面看一段代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;iostream&gt;using namespace std;class OBJ1&#123;public: OBJ1() &#123; cout&lt;&lt;"OBJ1"&lt;&lt;endl; &#125; ~OBJ1() &#123; cout&lt;&lt;"~OBJ1"&lt;&lt;endl; &#125;&#125;;class OBJ2&#123;public: OBJ2() &#123; cout&lt;&lt;"OBJ2"&lt;&lt;endl; &#125; ~OBJ2() &#123; cout&lt;&lt;"~OBJ2"&lt;&lt;endl; &#125;&#125;;class Base1&#123;public: Base1() &#123; cout&lt;&lt;"Base1"&lt;&lt;endl; &#125; ~Base1() &#123; cout&lt;&lt;"~Base1"&lt;&lt;endl; &#125;&#125;;class Base2&#123;public: Base2() &#123; cout&lt;&lt;"Base2"&lt;&lt;endl; &#125; ~Base2() &#123; cout&lt;&lt;"~Base2"&lt;&lt;endl; &#125;&#125;;class Base3&#123;public: Base3() &#123; cout&lt;&lt;"Base3"&lt;&lt;endl; &#125; ~Base3() &#123; cout&lt;&lt;"~Base3"&lt;&lt;endl; &#125;&#125;;class Base4&#123;public: Base4() &#123; cout&lt;&lt;"Base4"&lt;&lt;endl; &#125; ~Base4() &#123; cout&lt;&lt;"~Base4"&lt;&lt;endl; &#125;&#125;;class Derived: public Base1, virtual public Base2, public Base3, virtual public Base4&#123;public: Derived():Base4(),Base3(),Base2(),Base1(),obj2(),obj1()&#123;&#125;protected: OBJ1 obj1; OBJ2 obj2;&#125;;int main()&#123; Derived aa; return 0;&#125; 运行结果 12345678910111213Base2Base4Base1Base3OBJ1OBJ2~OBJ2~OBJ1~Base3~Base1~Base4~Base2Program ended with exit code: 0 由此可知C++中多重继承的构造顺序是1）虚函数优先构造，其顺序是按那个继承的顺序来的，而不是按初始化列表来的2）然后构造普通的基类，其顺序也是按那个继承的顺序来的，不是按初始化列表来的3）最后构造成员对象4）构造派生类自己的函数体 由此可知C++中多重继承的析构顺序是1）构造派生类自己的函数体2）析造成员对象3）然后析构普通的基类，其顺序也是按那个继承的顺序来的，也不是按初始化列表来的4）最后是那个虚基类]]></content>
  </entry>
  <entry>
    <title><![CDATA[析构函数为虚函数]]></title>
    <url>%2F2019%2F08%2F12%2F%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[转载 https://blog.csdn.net/zhangqk2016/article/details/51849535 多态是面向对象的一个基本属性，包括静态多态（编译阶段）和动态多态（运行阶段），静态多态主要是指函数参数不同产生的多态性，是在编译阶段可以识别的一种多态机制，而运行时多态则主要用于基类指针指向派生类对象时，可以通过基类指针直接调用派生类的对象函数，当然这种多态是通过虚函数实现的。 虚函数的目的就是通知系统在函数调用时能够自动识别对应的类对象类型，从而能够根据指针所指类型调用对应的类对象，实现函数调用时的多态性。对于析构函数而言，同样适用于上述规则。如果析构函数不是虚函数，那么在调用该函数时（对象被删除时）则只会调用当前对象对应的类的析构函数，这对于直接定义的对象是没有什么影响的，但是对于使用基类指向派生类的指针而言，因为基类指针实际上是基类类型，所以析构时自然只会调用基类的析构函数，这就可能产生内存泄漏（因为派生类的析构函数不被调用）。所以如果确定程序中有基类指针指向派生类的问题，则必须将基类的析构函数指定为虚函数，如此才能确保NEW出来的对象被正确的DELETE。 以下是几个示例程序，用于方便理解： 123456789101112131415161718class ClxBase&#123; public: ClxBase() &#123;&#125;; ~ClxBase() &#123; cout &lt;&lt; "Output from the destructor of class ClxBase!" &lt;&lt; endl; &#125;; void DoSomething() &#123; cout &lt;&lt; "Do something in class ClxBase!" &lt;&lt; endl; &#125;; &#125;; class ClxDerived : public ClxBase&#123; public: ClxDerived() &#123;&#125;; ~ClxDerived() &#123; cout &lt;&lt; "Output from the destructor of class ClxDerived!" &lt;&lt; endl; &#125;; void DoSomething() &#123; cout &lt;&lt; "Do something in class ClxDerived!" &lt;&lt; endl; &#125;; &#125;; 示例程序一： 123456789int main()&#123; ClxBase base; ClxDerived derived; base.DoSomething(); derived.DoSomething(); return 0; &#125; 运行结果： Do something in class ClxBase! Do something in class ClxDerived! Output from the destructor of class ClxDerived! Output from the destructor of class ClxBase! Output from the destructor of class ClxBase!分析： 从以上实例程序可以发现，正常构造的对象，派生类的析构函数会主动调用基类的析构函数，所以不会存在内存泄漏问题。 示例程序二： 123456int main()&#123; ClxDerived *p = new ClxDerived; p-&gt;DoSomething(); delete p; return 0; &#125; 运行结果： Do something in class ClxDerived! Output from the destructor of class ClxDerived! Output from the destructor of class ClxBase!分析：从以上结果可以发现，派生类的指针在析构时，同样是运行指针所对应类型的派生类的析构函数，而此析构函数自然会调用基类的析构函数，所以也不会产生内存泄漏。 实例程序三： 123456int main()&#123; ClxBase *p = new ClxDerived; p-&gt;DoSomething(); delete p; return 0; &#125; 运行结果： Do something in class ClxBase! Output from the destructor of class ClxBase!分析： 从以上结果可以发现，基类指针在析构时，会调用基类的析构函数，纵然其指向派生类，但其依然会调用基类的析构，所以派生类中如有需要释放的内存空间，则必然得不到释放，从而产生内存泄漏。 示例程序四： 1234567891011121314151617181920class ClxBase&#123; public: ClxBase() &#123;&#125;; virtual ~ClxBase() &#123;cout &lt;&lt; "Output from the destructor of class ClxBase!" &lt;&lt; endl;&#125;; virtual void DoSomething() &#123; cout &lt;&lt; "Do something in class ClxBase!" &lt;&lt; endl; &#125;; &#125;; class ClxDerived : public ClxBase&#123; public: ClxDerived() &#123;&#125;; ~ClxDerived() &#123; cout &lt;&lt; "Output from the destructor of class ClxDerived!" &lt;&lt; endl; &#125;; void DoSomething() &#123; cout &lt;&lt; "Do something in class ClxDerived!" &lt;&lt; endl; &#125;; &#125;; int main()&#123; ClxBase *p = new ClxDerived; p-&gt;DoSomething(); delete p; return 0; &#125; 运行结果： Do something in class ClxDerived! Output from the destructor of class ClxDerived! Output from the destructor of class ClxBase!分析： 以上结果可以发现，不管是普通成员函数还是析构函数，只有定义为虚函数，才能够在基类指针指向派生类对象时调用所指向对象的响应函数，从而在函数析构时能够正确的delete掉new出来的对象，不产生内存泄漏。]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于虚函数与纯虚函数的几点小记]]></title>
    <url>%2F2019%2F08%2F12%2F%E5%85%B3%E4%BA%8E%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%87%A0%E7%82%B9%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[关于虚函数与纯虚函数的几点虚函数虚函数的关键字是virtual虚函数是提供一种“推迟联编”或者“动态联编”的功能，来实现多态性，形成虚指针。虚函数的调用并不是在编译时刻被确定的，而是在运行时刻被确定的。 一个代码示列： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;using namespace std;class Base1&#123;public: virtual void display()const;&#125;;void Base1::display()const&#123; cout&lt;&lt;"Base1::display()"&lt;&lt;endl;&#125;class Base2:public Base1&#123;public: void display()const;&#125;;void Base2::display()const&#123; cout&lt;&lt;"Base2::display()"&lt;&lt;endl;&#125;class Derived:public Base1&#123;public: void display()const;&#125;;void Derived::display()const&#123; cout&lt;&lt;"Derived::display()"&lt;&lt;endl;&#125;void fun(Base1 *ptr)&#123; ptr-&gt;display();&#125;int main()&#123; Base1 base1; Base2 base2; Derived derived; fun(&amp;base1); fun(&amp;base2); fun(&amp;derived); return 0;&#125; 运行结果： 1234Base1::display()Base2::display()Derived::display()Program ended with exit code: 0 纯虚函数纯虚函数是在基类中声明的虚函数，它在基类中没有定义，所以不能实例化不能产生对象。在基类中实现纯虚函数的方法是在函数原型后加“=0” virtual void funtion1()=0其中虚函数的主要作用是：使基类中的纯虚函数仅仅只是继承函数的一个接口。其中含有纯虚函数的类被称为抽象类，若抽象类在继承中纯虚函数还是没有被实现则还是抽象类抽象类的作用：产生一个接口被派生类继承 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;class Base1&#123;public: virtual void display() const=0;&#125;;class Base2:public Base1&#123;public: void display() const;&#125;;void Base2::display()const&#123; cout&lt;&lt;"Base2::display()"&lt;&lt;endl;&#125;class Derived:public Base2&#123;public: void display()const;&#125;;void Derived::display()const&#123; cout&lt;&lt;"Derivd::display()"&lt;&lt;endl;&#125;void fun(Base1 *ptr)&#123; ptr-&gt;display();&#125;int main()&#123; Base2 base2; Derived derived; fun(&amp;base2); fun(&amp;derived); return 0;&#125; 运行结果 123Base2::display()Derivd::display()Program ended with exit code: 0 详情请看 https://blog.csdn.net/wang13342322203/article/details/80512330]]></content>
  </entry>
  <entry>
    <title><![CDATA[浅谈Python多进程与多线程]]></title>
    <url>%2F2019%2F08%2F12%2F%E6%B5%85%E8%B0%88Python%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[浅谈Python多进程与多线程@[toc] 什么是进程，什么是线程进程进程是程序的一次动态执行过程，它对应了从代码加载、执行到执行完毕的一个完整过程。进程是资源分配的最小单位，进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵一个进程若不存在多线程则相当于线程 线程线程是程序执行的最小单位，每个线程中可以实现资源的共享、通信等操作， 但线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。 两者的区别 进程 线程 相同点 两者都是实现多个任务同时运行的方式 不同点 进程拥有独立的资源，进程间相互独立，互不打扰，但线程之间更容易实现共享，同时多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。 多进程在Unix与Linux中系统支持fork()，但在我们常见的系统中不容许Windows可以使用，但Mac OS X与Linux可以使用,但Python是一门可以跨平台的编程语言，对任意系统都支持multiprocessing 其中：os.getpid() 获取当前进程的PID号os.getppid() 获取当前进程父进程的PID号 代码实现Mac OS X下使用fork（）创建子进程fork()语法： 功能：为当前进程创建一个子进程 参数：无 返回值：0 和 子进程PID（在父进程中） &lt; 0 子进程创建失败 = 0 在子进程中的返回值 &gt; 0 在父进程中的返回值 fork()很特殊，它是一个调用一次，返回两次的函数子进程永远返回0，而父进程返回子进程的ID,所以一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用getppid()就可以拿到父进程的ID。 12345678910111213# -*- coding:utf-8 -*-#！usr/bin/env pythonimport os# fork()属于系统内建函数，需从OS模块引入print 'process (%s) strat...' %os.getpid()pid = os.fork()# 调用一次，返回两次if pid == 0:# 判断是否为子进程 print "I'm child process (%s) and my parent is %s" %(os.getpid(),os.getppid())else: print "I (%s) just created a child process (%s)." %(os.getpid(),pid) 输出 123process (58196) strat...I (58196) just created a child process (58198).I&apos;m child process (58198) and my parent is 58196 使用multiprocessing由于windows不可以使用fork（），但python为所有操作系统准备了multiprocess供它们创建子线程 创建子进程时，只需要传入一个执行函数和函数的参数，创建一个Process实例，用start()方法启动，这样创建进程比fork()还要简单。join()方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。 1234567891011121314151617181920212223# -*- coding:utf-8 -*-#！usr/bin/env pythonfrom multiprocessing import Process# 从multiprocessing模块引入Processimport osdef fun(name): print 'Run child process %s(%s)...'%(name,os.getpid()) # 打印当前进程if __name__=='__main__': # 若在本模块运行时 print 'Parent process %s.'%os.getpid() # 打印父进程 p = Process(target=fun,args=('test',)) # 创建一个子进程 print 'Process will start.' p.start() # 开始运行子进程 p.join() # 停止运行子进程 print 'Process end' 输出 1234Parent process 61028.Process will start.Run child process test(61029)...Process end 进程池如果要启动大量的子进程，可以用进程池的方式批量创建子进程： 关键字为poll，Pool的默认大小是CPU的核数；但它也可以设置参数如果为pool（5）则是申请有5个子进程的进程池注意：对Pool对象调用join()方法会等待所有子进程执行完毕，调用join()之前必须先调用close()，调用close()之后就不能继续添加新的Process了。 12345678910111213141516171819202122232425# -*- coding:utf-8 -*-#！usr/bin/env pythonfrom multiprocessing import Pool# 从multiprocess模块引入Poolimport os,time,randomdef long_time_task(name): print 'Run task%s(%s)' % (name, os.getpid()) start = time.time() time.sleep(random.random()*3) # random.random（）产生一个0～1的随机数 end = time.time() print 'Task %s runs %0.2f seconds' % (name, (end-start)) # 输出任务名与运行时间差 if __name__ == '__main__': print 'Parent process %s.' % os.getpid() p = Pool() # 生成一个进程池 for i in range(5): p.apply_async(long_time_task, args=(i,)) print 'Waiting for all subprocesses done...' p.close() p.join() print 'All subprocess done' 输出 1234567891011121314Parent process 66221.Waiting for all subprocesses done...Run task0(66223)Run task1(66224)Run task2(66225)Run task3(66226)Task 1 runs 0.69 secondsRun task4(66224)Task 4 runs 0.91 secondsTask 2 runs 1.97 secondsTask 3 runs 2.19 secondsTask 0 runs 3.00 secondsAll subprocess done3.03261709213 因为我使用的是4核处理器，所以task 4要等待前面某个task完成后才执行 多进程的通信multiprocessing.Queue()Queue是多进程安全的队列，可以使用Queue实现多进程之间的数据传递。put方法用以插入数据到队列中，put方法还有两个可选参数：blocked和timeout。如果blocked为True（默认值），并且timeout为正值，该方法会阻塞timeout指定的时间，直到该队列有剩余的空间。如果超时，会抛出Queue.Full异常。如果blocked为False，但该Queue已满，会立即抛出Queue.Full异常。 get方法可以从队列读取并且删除一个元素。同样，get方法有两个可选参数：blocked和timeout。如果blocked为True（默认值），并且timeout为正值，那么在等待时间内没有取到任何元素，会抛出Queue.Empty异常。如果blocked为False，有两种情况存在，如果Queue有一个值可用，则立即返回该值，否则，如果队列为空，则立即抛出Queue.Empty异常 以Queue为例，在父进程中创建两个子进程，一个往Queue里写数据，一个从Queue里读数据： ==multiprcessing.Queue.put() 为 入队操作== ==multiprcessing.Queue.get() 为 出队操作== 1234567891011121314151617181920212223242526# -*- coding:utf-8 -*-#！usr/bin/env pythonimport multiprocessingdef writer_proc(q): try: q.put(1, block = False) except: pass def reader_proc(q): try: print q.get(block = False) except: passif __name__ == "__main__": q = multiprocessing.Queue() writer = multiprocessing.Process(target=writer_proc, args=(q,)) writer.start() reader = multiprocessing.Process(target=reader_proc, args=(q,)) reader.start() reader.join() writer.join() multiprocessing.Pipe()Pipe方法返回(conn1, conn2)代表一个管道的两个端。Pipe方法有duplex参数，如果duplex参数为True(默认值)，那么这个管道是全双工模式，也就是说conn1和conn2均可收发。duplex为False，conn1只负责接受消息，conn2只负责发送消息。 send和recv方法分别是发送和接受消息的方法。例如，在全双工模式下，可以调用conn1.send发送消息，conn1.recv接收消息。如果没有消息可接收，recv方法会一直阻塞。如果管道已经被关闭，那么recv方法会抛出EOFError。 1234567891011121314151617181920212223242526272829303132# -*- coding:utf-8 -*-#！usr/bin/env pythonimport multiprocessingimport timedef proc1(pipe): while True: for i in range(10): print "send: %s" %(i) pipe.send(i) # 向pipe中发送i值 time.sleep(1)def proc2(pipe): while True: print "proc2 rev:", pipe.recv() # 接受i值 time.sleep(1)if __name__ == "__main__": pipe = multiprocessing.Pipe() # 申请一个pipe p1 = multiprocessing.Process(target=proc1, args=(pipe[0],)) p2 = multiprocessing.Process(target=proc2, args=(pipe[1],)) # 生成两个子进程p1，p2 p1.start() p2.start() # 开始执行进程 p1.join() p2.join() # 结束进程 多线程Python的标准库提供了两个模块：thread和threading，thread是低级模块，threading是高级模块，对thread进行了封装。绝大多数情况下，我们只需要使用threading这个高级模块。 代码实现 单线程 1234567891011121314151617#-*- coding:utf-8 -*-#！usr/bin/env pythonimport timedef fun1(): for i in range(3): print '我在看书',time.ctime() time.sleep(1)def fun2(): for i in range(3): print "我在听歌",time.ctime() time.sleep(1)fun1()fun2() 输出 123456我在看书 Fri Aug 9 22:34:41 2019我在看书 Fri Aug 9 22:34:42 2019我在看书 Fri Aug 9 22:34:43 2019我在听歌 Fri Aug 9 22:34:44 2019我在听歌 Fri Aug 9 22:34:45 2019我在听歌 Fri Aug 9 22:34:46 2019 多线程输出 1234567891011121314151617181920212223242526#-*- coding:utf-8 -*-#！usr/bin/env pythonimport timeimport threadingdef fun1(): for i in range(3): print '我在看书',time.ctime() time.sleep(1)def fun2(): for i in range(3): print "我在听歌",time.ctime() time.sleep(1)p1 = threading.Thread(target=fun1)# 创建一个线程p1p2 = threading.Thread(target=fun2)# 创建一个线程p2p1.start()p2.start()# 执行线程p1.join()p2.join()# 结束线程 123456我在看书 Fri Aug 9 22:37:44 2019我在听歌 Fri Aug 9 22:37:44 2019我在看书 Fri Aug 9 22:37:45 2019我在听歌 Fri Aug 9 22:37:45 2019我在听歌 Fri Aug 9 22:37:46 2019我在看书 Fri Aug 9 22:37:46 2019 线程通信由于线程通信造成的混乱多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了 1234567891011121314151617181920#-*- coding:utf-8 -*-#！usr/bin/env pythonimport timeimport threadingcount = 5def fun(n): global count for i in range(5): count += n time.sleep(1) count -= n print countp1 = threading.Thread(target=fun,args=(5,))p2 = threading.Thread(target=fun,args=(3,))p1.start()p2.start() 输出 123456789105 810810858105 解决方案在Python中提供了关键字lock来防止由于线程通信造成的混乱。由于锁（lock）只有一个，无论多少线程，同一时刻最多只有一个线程持有该锁，所以，不会造成修改的冲突。所以获得lock的线程将会优先执行。所以lock会使各个线程依次执行。但使用lock时，threading.Lock()，要注意获取和释放锁， lock.acquire()、 lock.release() 示例代码： 1234567891011121314151617181920212223242526272829303132#-*- coding:utf-8 -*-#！usr/bin/env pythonimport threadingdef fun1(): global A, lock lock.acquire() for i in range(10): A += 1 print "Thread-1", A lock.release()def fun2(): global A, lock lock.acquire() for i in range(10): A += 10 print "Thread-2", A lock.release()if __name__ == '__main__': lock = threading.Lock() A = 0 t1 = threading.Thread(target=fun1) t2 = threading.Thread(target=fun2) t1.start() t2.start() t1.join() t2.join() 输出 1234567891011121314151617181920Thread-1 1Thread-1 2Thread-1 3Thread-1 4Thread-1 5Thread-1 6Thread-1 7Thread-1 8Thread-1 9Thread-1 10Thread-2 20Thread-2 30Thread-2 40Thread-2 50Thread-2 60Thread-2 70Thread-2 80Thread-2 90Thread-2 100Thread-2 110]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F08%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
